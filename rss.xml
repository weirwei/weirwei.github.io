<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>浩雨未倾</title><link>http://blog.weirwei.cn/</link><description>Recent content on 浩雨未倾</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 04 Dec 2023 00:00:00 +0800</lastBuildDate><atom:link href="http://blog.weirwei.cn/rss.xml" rel="self" type="application/rss+xml"/><item><title>200. 岛屿数量</title><link>http://blog.weirwei.cn/leetcode/leetcode_number-of-islands/</link><pubDate>Mon, 04 Dec 2023 00:00:00 +0800</pubDate><guid>http://blog.weirwei.cn/leetcode/leetcode_number-of-islands/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://leetcode.cn/problems/number-of-islands/" title="https://leetcode.cn/problems/number-of-islands/" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
https://leetcode.cn/problems/number-of-islands/
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>给你一个由 &amp;lsquo;1&amp;rsquo;（陆地）和 &amp;lsquo;0&amp;rsquo;（水）组成的的二维网格，请你计算网格中岛屿的数量。&lt;/p>
&lt;p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。&lt;/p>
&lt;p>此外，你可以假设该网格的四条边均被水包围。&lt;/p></description></item><item><title>33. 搜索旋转排序数组</title><link>http://blog.weirwei.cn/leetcode/leetcode_search-in-rotated-sorted-array/</link><pubDate>Sun, 03 Dec 2023 00:00:00 +0800</pubDate><guid>http://blog.weirwei.cn/leetcode/leetcode_search-in-rotated-sorted-array/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/" title="https://leetcode.cn/problems/search-in-rotated-sorted-array/" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
https://leetcode.cn/problems/search-in-rotated-sorted-array/
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>整数数组 nums 按升序排列，数组中的值 互不相同 。&lt;/p>
&lt;p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &amp;lt;= k &amp;lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], &amp;hellip;, nums[n-1], nums[0], nums[1], &amp;hellip;, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。&lt;/p>
&lt;p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。&lt;/p>
&lt;p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。&lt;/p></description></item><item><title>1. 两数之和</title><link>http://blog.weirwei.cn/leetcode/leetcode_two-sum/</link><pubDate>Tue, 21 Nov 2023 00:00:00 +0800</pubDate><guid>http://blog.weirwei.cn/leetcode/leetcode_two-sum/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://leetcode.cn/problems/two-sum/" title="https://leetcode.cn/problems/two-sum/" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
https://leetcode.cn/problems/two-sum/
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。&lt;/p>
&lt;p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。&lt;/p>
&lt;p>你可以按任意顺序返回答案。&lt;/p></description></item><item><title>102. 二叉树的层序遍历</title><link>http://blog.weirwei.cn/leetcode/leetcode_binary-tree-level-order-traversal/</link><pubDate>Tue, 21 Nov 2023 00:00:00 +0800</pubDate><guid>http://blog.weirwei.cn/leetcode/leetcode_binary-tree-level-order-traversal/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" title="https://leetcode.cn/problems/binary-tree-level-order-traversal/" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
https://leetcode.cn/problems/binary-tree-level-order-traversal/
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。&lt;/p></description></item><item><title>21. 合并两个有序链表</title><link>http://blog.weirwei.cn/leetcode/leetcode_merge-two-sorted-lists/</link><pubDate>Mon, 20 Nov 2023 00:00:00 +0800</pubDate><guid>http://blog.weirwei.cn/leetcode/leetcode_merge-two-sorted-lists/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://leetcode.cn/problems/merge-two-sorted-lists/" title="https://leetcode.cn/problems/merge-two-sorted-lists/" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
https://leetcode.cn/problems/merge-two-sorted-lists/
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。&lt;/p></description></item><item><title>409. 最长回文串</title><link>http://blog.weirwei.cn/leetcode/leetcode_longest-palindrome/</link><pubDate>Thu, 16 Nov 2023 00:00:00 +0800</pubDate><guid>http://blog.weirwei.cn/leetcode/leetcode_longest-palindrome/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://leetcode.cn/problems/longest-palindrome/" title="https://leetcode.cn/problems/longest-palindrome/" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
https://leetcode.cn/problems/longest-palindrome/
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。&lt;/p>
&lt;p>在构造过程中，请注意 区分大小写 。比如 &amp;ldquo;Aa&amp;rdquo; 不能当做一个回文字符串。&lt;/p></description></item><item><title>912. 排序数组</title><link>http://blog.weirwei.cn/leetcode/leetcode_sort-an-array/</link><pubDate>Wed, 01 Nov 2023 00:00:00 +0800</pubDate><guid>http://blog.weirwei.cn/leetcode/leetcode_sort-an-array/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://leetcode.cn/problems/sort-an-array/" title="https://leetcode.cn/problems/sort-an-array/" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
https://leetcode.cn/problems/sort-an-array/
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>给你一个整数数组 &lt;code>nums&lt;/code>，请你将该数组升序排列。&lt;/p></description></item><item><title>53. 最大子数组和</title><link>http://blog.weirwei.cn/leetcode/leetcode_maximum-subarray/</link><pubDate>Tue, 31 Oct 2023 00:00:00 +0800</pubDate><guid>http://blog.weirwei.cn/leetcode/leetcode_maximum-subarray/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://leetcode.cn/problems/maximum-subarray/" title="https://leetcode.cn/problems/maximum-subarray/" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
https://leetcode.cn/problems/maximum-subarray/
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p>
&lt;p>子数组 是数组中的一个连续部分。&lt;/p></description></item><item><title>15. 三数之和</title><link>http://blog.weirwei.cn/leetcode/leetcode_3sum/</link><pubDate>Mon, 30 Oct 2023 00:00:00 +0800</pubDate><guid>http://blog.weirwei.cn/leetcode/leetcode_3sum/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://leetcode.cn/problems/3sum/" title="https://leetcode.cn/problems/3sum/" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
https://leetcode.cn/problems/3sum/
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>给你一个整数数组 nums ，判断是否存在三元组 &lt;code>[nums[i], nums[j], nums[k]]&lt;/code> 满足 &lt;code>i != j、i != k 且 j != k&lt;/code> ，同时还满足 &lt;code>nums[i] + nums[j] + nums[k] == 0&lt;/code> 。请&lt;/p>
&lt;p>你返回所有和为 0 且不重复的三元组。&lt;/p>
&lt;p>注意：答案中不可以包含重复的三元组。&lt;/p></description></item><item><title>25. K 个一组翻转链表</title><link>http://blog.weirwei.cn/leetcode/leetcode_reverse-nodes-in-k-group/</link><pubDate>Fri, 20 Oct 2023 00:00:00 +0800</pubDate><guid>http://blog.weirwei.cn/leetcode/leetcode_reverse-nodes-in-k-group/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/" title="https://leetcode.cn/problems/reverse-nodes-in-k-group/" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
https://leetcode.cn/problems/reverse-nodes-in-k-group/
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。&lt;/p>
&lt;p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。&lt;/p>
&lt;p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。&lt;/p></description></item><item><title>215. 数组中的第K个最大元素</title><link>http://blog.weirwei.cn/leetcode/leetcode_kth-largest-element-in-an-array/</link><pubDate>Thu, 19 Oct 2023 00:00:00 +0800</pubDate><guid>http://blog.weirwei.cn/leetcode/leetcode_kth-largest-element-in-an-array/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/" title="https://leetcode.cn/problems/kth-largest-element-in-an-array/" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
https://leetcode.cn/problems/kth-largest-element-in-an-array/
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>给定整数数组 &lt;code>nums&lt;/code> 和整数 &lt;code>k&lt;/code>，请返回数组中第 &lt;code>k&lt;/code> 个最大的元素。&lt;/p>
&lt;p>请注意，你需要找的是数组排序后的第 &lt;code>k&lt;/code> 个最大的元素，而不是第 &lt;code>k&lt;/code> 个不同的元素。&lt;/p>
&lt;p>你必须设计并实现时间复杂度为 &lt;code>O(n)&lt;/code> 的算法解决此问题。&lt;/p></description></item><item><title>go 结构体包含接口成员进行反序列化</title><link>http://blog.weirwei.cn/practical/go_struct_contains_interface/</link><pubDate>Wed, 18 Oct 2023 18:45:00 +0800</pubDate><guid>http://blog.weirwei.cn/practical/go_struct_contains_interface/</guid><description>&lt;blockquote>
&lt;p>工作中遇到一个问题，结构体包含接口类型的成员时，在反序列化的时候会报错。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-golang" data-lang="golang">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Task 接口类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">type&lt;/span> Task &lt;span style="color:#8be9fd;font-style:italic">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">Exec&lt;/span>() &lt;span style="color:#8be9fd">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// TaskA Task接口的实现类A
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">type&lt;/span> TaskA &lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> A &lt;span style="color:#8be9fd">string&lt;/span> &lt;span style="color:#f1fa8c">`json:&amp;#34;a&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> (ta &lt;span style="color:#ff79c6">*&lt;/span>TaskA) &lt;span style="color:#50fa7b">Exec&lt;/span>() &lt;span style="color:#8be9fd">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;TaskA Exec&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// TaskB Task接口的实现类B
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">type&lt;/span> TaskB &lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> B &lt;span style="color:#8be9fd">string&lt;/span> &lt;span style="color:#f1fa8c">`json:&amp;#34;b&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> (tb &lt;span style="color:#ff79c6">*&lt;/span>TaskB) &lt;span style="color:#50fa7b">Exec&lt;/span>() &lt;span style="color:#8be9fd">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;TaskB Exec&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// MixedStruct 反序列化目标结构体
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">type&lt;/span> MixedStruct &lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Id &lt;span style="color:#8be9fd">uint64&lt;/span> &lt;span style="color:#f1fa8c">`json:&amp;#34;id&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Task Task &lt;span style="color:#f1fa8c">`json:&amp;#34;task&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>146. LRU 缓存</title><link>http://blog.weirwei.cn/leetcode/leetcode_lru-cache/</link><pubDate>Thu, 12 Oct 2023 00:00:00 +0800</pubDate><guid>http://blog.weirwei.cn/leetcode/leetcode_lru-cache/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://leetcode.cn/problems/lru-cache" title="https://leetcode.cn/problems/lru-cache" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
https://leetcode.cn/problems/lru-cache
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。&lt;/p>
&lt;p>实现 &lt;code>LRUCache&lt;/code> 类：&lt;/p>
&lt;ul>
&lt;li>&lt;code>LRUCache(int capacity)&lt;/code> 以 正整数 作为容量 &lt;code>capacity&lt;/code> 初始化 &lt;code>LRU&lt;/code> 缓存&lt;/li>
&lt;li>&lt;code>int get(int key)&lt;/code> 如果关键字 &lt;code>key&lt;/code> 存在于缓存中，则返回关键字的值，否则返回 &lt;code>-1 &lt;/code>。&lt;/li>
&lt;li>&lt;code>void put(int key, int value)&lt;/code> 如果关键字 &lt;code>key&lt;/code> 已经存在，则变更其数据值 &lt;code>value&lt;/code> ；如果不存在，则向缓存中插入该组 &lt;code>key-value&lt;/code> 。如果插入操作导致关键字数量超过 &lt;code>capacity&lt;/code> ，则应该 逐出 最久未使用的关键字。
函数 &lt;code>get&lt;/code> 和 &lt;code>put&lt;/code> 必须以 &lt;code>O(1)&lt;/code> 的平均时间复杂度运行。&lt;/li>
&lt;/ul></description></item><item><title>206. 反转链表</title><link>http://blog.weirwei.cn/leetcode/leetcode_reverse-linked-list/</link><pubDate>Wed, 11 Oct 2023 00:00:00 +0800</pubDate><guid>http://blog.weirwei.cn/leetcode/leetcode_reverse-linked-list/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://leetcode.cn/problems/reverse-linked-list" title="https://leetcode.cn/problems/reverse-linked-list" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
https://leetcode.cn/problems/reverse-linked-list
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。&lt;/p></description></item><item><title>3. 无重复字符的最长子串</title><link>http://blog.weirwei.cn/leetcode/leetcode_longest-substring-without-repeating-characters/</link><pubDate>Tue, 10 Oct 2023 00:00:00 +0800</pubDate><guid>http://blog.weirwei.cn/leetcode/leetcode_longest-substring-without-repeating-characters/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/" title="https://leetcode.cn/problems/longest-substring-without-repeating-characters/" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
https://leetcode.cn/problems/longest-substring-without-repeating-characters/
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p></description></item><item><title>MySQL where 范围查询和 order by 关键字无法同时命中索引</title><link>http://blog.weirwei.cn/practical/index_in_orderby/</link><pubDate>Wed, 27 Sep 2023 15:18:00 +0800</pubDate><guid>http://blog.weirwei.cn/practical/index_in_orderby/</guid><description>&lt;blockquote>
&lt;p>开发中，使用 in 和 order by 的时候，发现无法同时命中索引。&lt;/p>
&lt;/blockquote>
&lt;p>使用 &lt;code>IN&lt;/code> 运算符来过滤行时，&lt;code>MySQL&lt;/code> 会先使用索引来定位表中的行，并将这些行的所有数据读入内存中。随后，&lt;code>MySQL&lt;/code> 会根据查询语句中的 &lt;code>ORDER BY&lt;/code> 子句对这些数据进行排序。&lt;/p></description></item><item><title>Gorm 的黑魔法</title><link>http://blog.weirwei.cn/practical/gorm_black_magic/</link><pubDate>Wed, 27 Sep 2023 15:10:00 +0800</pubDate><guid>http://blog.weirwei.cn/practical/gorm_black_magic/</guid><description>&lt;blockquote>
&lt;p>小伙看到同事写的Gorm黑魔法，逐渐不淡定了。&lt;/p>
&lt;/blockquote>
&lt;p>开发过程中，看到同事的代码写了这么一段：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>db = db.&lt;span style="color:#50fa7b">Session&lt;/span>(&lt;span style="color:#ff79c6">&amp;amp;&lt;/span>gorm.Session{Context: db.Statement.Context}).&lt;span style="color:#50fa7b">FirstOrCreate&lt;/span>(&lt;span style="color:#ff79c6">&amp;amp;&lt;/span>entity)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> db.Error &lt;span style="color:#ff79c6">!=&lt;/span>&lt;span style="color:#ff79c6">nil&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> components.ErrorDbInsert.&lt;span style="color:#50fa7b">WrapPrintf&lt;/span>(db.Error, &lt;span style="color:#f1fa8c">&amp;#34;Insert error, entity:%s&amp;#34;&lt;/span>, utils.&lt;span style="color:#50fa7b">ToJson&lt;/span>(entity))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> db.RowsAffected &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> components.ErrorAlreadyExist
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>MySQL 索引排序</title><link>http://blog.weirwei.cn/learning/mysql_index_sort/</link><pubDate>Wed, 27 Sep 2023 14:52:00 +0800</pubDate><guid>http://blog.weirwei.cn/learning/mysql_index_sort/</guid><description>&lt;blockquote>
&lt;p>开发过程中发现SQL一直filesort，所以研究一下到低怎么才能使用索引进行排序。&lt;/p>
&lt;/blockquote></description></item><item><title>go 的切片扩容</title><link>http://blog.weirwei.cn/learning/slice_expand/</link><pubDate>Wed, 27 Sep 2023 11:49:00 +0800</pubDate><guid>http://blog.weirwei.cn/learning/slice_expand/</guid><description>&lt;blockquote>
&lt;p>在uber 的go语言编码规范中有这么一条，2.48s 和0.21s 的差距还是很惊人了，我很好奇，why？&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="http://blog.weirwei.cn/imgs/img-lazy-loading.gif" data-src="http://blog.weirwei.cn/imgs/post/slice_expand/20211101012619128.png" alt="20211101012619128" />&lt;/p>
&lt;p>切片在&lt;code>append&lt;/code>的时候可能会自动扩容，看一下相关源码。&lt;/p></description></item><item><title>go test 的内联问题</title><link>http://blog.weirwei.cn/practical/inlining/</link><pubDate>Wed, 27 Sep 2023 11:00:00 +0800</pubDate><guid>http://blog.weirwei.cn/practical/inlining/</guid><description>&lt;blockquote>
&lt;p>使用&lt;code>monkey&lt;/code>对函数进行打桩单测的时候，发现打桩函数没有生效。&lt;/p>
&lt;/blockquote>
&lt;p>习惯直接使用IDE的可视化的&lt;code>run&lt;/code>和&lt;code>debug&lt;/code>功能进行跑单测，没有关注到具体执行的命令。&lt;/p></description></item><item><title>Typora + PicGo + Gitee 解放你对图片的管理</title><link>http://blog.weirwei.cn/tools/typora+picgo+gitee/</link><pubDate>Tue, 26 Sep 2023 18:51:00 +0800</pubDate><guid>http://blog.weirwei.cn/tools/typora+picgo+gitee/</guid><description>&lt;blockquote>
&lt;p>使用&lt;code>markdown&lt;/code>做笔记的时候，使用图片时，需要将图片放在指定文件夹，然后引用。这么做每次添加图片都比较困难，并且不便于多端使用。&lt;/p>
&lt;/blockquote>
&lt;p>使用&lt;code>PicGo&lt;/code>作为图床，将图片托管到&lt;code>Gitee&lt;/code>，在使用&lt;code>Typora&lt;/code>做笔记的时候可以直接无缝上传图片。&lt;/p></description></item><item><title>关于 Hugo NexT 组织</title><link>http://blog.weirwei.cn/about.html</link><pubDate>Thu, 09 Jun 2022 20:12:52 +0800</pubDate><guid>http://blog.weirwei.cn/about.html</guid><description>Hugo NexT 组织是由众多喜爱 NexT 主题及风格的世界各地友人共同组建而成，为的就是让这个主题继续在 Hugo 引擎中也能得到发扬光大，在此也欢迎你的加入！ 我们的愿景</description></item><item><title>站点示例</title><link>http://blog.weirwei.cn/flinks.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://blog.weirwei.cn/flinks.html</guid><description>如想交换本站友情链接，请在评论区留下你的站点信息，格式参考如下： - name: Hugo-NexT desc: Hugo NexT 官方预览网站。 avatar: https://hugo-next.eu.org/imgs/hugo_next_avatar.png link: https://hugo-next.eu.org</description></item></channel></rss>