<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>leetcode on 浩雨未倾</title><link>http://blog.weirwei.cn/categories/leetcode/</link><description>Recent content in leetcode on 浩雨未倾</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 31 Oct 2023 00:00:00 +0800</lastBuildDate><atom:link href="http://blog.weirwei.cn/categories/leetcode/rss.xml" rel="self" type="application/rss+xml"/><item><title>53. 最大子数组和</title><link>http://blog.weirwei.cn/leetcode/leetcode_maximum-subarray/</link><pubDate>Tue, 31 Oct 2023 00:00:00 +0800</pubDate><guid>http://blog.weirwei.cn/leetcode/leetcode_maximum-subarray/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://leetcode.cn/problems/maximum-subarray/" title="https://leetcode.cn/problems/maximum-subarray/" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
https://leetcode.cn/problems/maximum-subarray/
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p>
&lt;p>子数组 是数组中的一个连续部分。&lt;/p></description></item><item><title>15. 三数之和</title><link>http://blog.weirwei.cn/leetcode/leetcode_3sum/</link><pubDate>Mon, 30 Oct 2023 00:00:00 +0800</pubDate><guid>http://blog.weirwei.cn/leetcode/leetcode_3sum/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://leetcode.cn/problems/3sum/" title="https://leetcode.cn/problems/3sum/" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
https://leetcode.cn/problems/3sum/
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>给你一个整数数组 nums ，判断是否存在三元组 &lt;code>[nums[i], nums[j], nums[k]]&lt;/code> 满足 &lt;code>i != j、i != k 且 j != k&lt;/code> ，同时还满足 &lt;code>nums[i] + nums[j] + nums[k] == 0&lt;/code> 。请&lt;/p>
&lt;p>你返回所有和为 0 且不重复的三元组。&lt;/p>
&lt;p>注意：答案中不可以包含重复的三元组。&lt;/p></description></item><item><title>25. K 个一组翻转链表</title><link>http://blog.weirwei.cn/leetcode/leetcode_reverse-nodes-in-k-group/</link><pubDate>Fri, 20 Oct 2023 00:00:00 +0800</pubDate><guid>http://blog.weirwei.cn/leetcode/leetcode_reverse-nodes-in-k-group/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/" title="https://leetcode.cn/problems/reverse-nodes-in-k-group/" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
https://leetcode.cn/problems/reverse-nodes-in-k-group/
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。&lt;/p>
&lt;p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。&lt;/p>
&lt;p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。&lt;/p></description></item><item><title>215. 数组中的第K个最大元素</title><link>http://blog.weirwei.cn/leetcode/leetcode_kth-largest-element-in-an-array/</link><pubDate>Thu, 19 Oct 2023 00:00:00 +0800</pubDate><guid>http://blog.weirwei.cn/leetcode/leetcode_kth-largest-element-in-an-array/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/" title="https://leetcode.cn/problems/kth-largest-element-in-an-array/" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
https://leetcode.cn/problems/kth-largest-element-in-an-array/
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>给定整数数组 &lt;code>nums&lt;/code> 和整数 &lt;code>k&lt;/code>，请返回数组中第 &lt;code>k&lt;/code> 个最大的元素。&lt;/p>
&lt;p>请注意，你需要找的是数组排序后的第 &lt;code>k&lt;/code> 个最大的元素，而不是第 &lt;code>k&lt;/code> 个不同的元素。&lt;/p>
&lt;p>你必须设计并实现时间复杂度为 &lt;code>O(n)&lt;/code> 的算法解决此问题。&lt;/p></description></item><item><title>146. LRU 缓存</title><link>http://blog.weirwei.cn/leetcode/leetcode_lru-cache/</link><pubDate>Thu, 12 Oct 2023 00:00:00 +0800</pubDate><guid>http://blog.weirwei.cn/leetcode/leetcode_lru-cache/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://leetcode.cn/problems/lru-cache" title="https://leetcode.cn/problems/lru-cache" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
https://leetcode.cn/problems/lru-cache
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。&lt;/p>
&lt;p>实现 &lt;code>LRUCache&lt;/code> 类：&lt;/p>
&lt;ul>
&lt;li>&lt;code>LRUCache(int capacity)&lt;/code> 以 正整数 作为容量 &lt;code>capacity&lt;/code> 初始化 &lt;code>LRU&lt;/code> 缓存&lt;/li>
&lt;li>&lt;code>int get(int key)&lt;/code> 如果关键字 &lt;code>key&lt;/code> 存在于缓存中，则返回关键字的值，否则返回 &lt;code>-1 &lt;/code>。&lt;/li>
&lt;li>&lt;code>void put(int key, int value)&lt;/code> 如果关键字 &lt;code>key&lt;/code> 已经存在，则变更其数据值 &lt;code>value&lt;/code> ；如果不存在，则向缓存中插入该组 &lt;code>key-value&lt;/code> 。如果插入操作导致关键字数量超过 &lt;code>capacity&lt;/code> ，则应该 逐出 最久未使用的关键字。
函数 &lt;code>get&lt;/code> 和 &lt;code>put&lt;/code> 必须以 &lt;code>O(1)&lt;/code> 的平均时间复杂度运行。&lt;/li>
&lt;/ul></description></item><item><title>206. 反转链表</title><link>http://blog.weirwei.cn/leetcode/leetcode_reverse-linked-list/</link><pubDate>Wed, 11 Oct 2023 00:00:00 +0800</pubDate><guid>http://blog.weirwei.cn/leetcode/leetcode_reverse-linked-list/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://leetcode.cn/problems/reverse-linked-list" title="https://leetcode.cn/problems/reverse-linked-list" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
https://leetcode.cn/problems/reverse-linked-list
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。&lt;/p></description></item><item><title>3. 无重复字符的最长子串</title><link>http://blog.weirwei.cn/leetcode/leetcode_longest-substring-without-repeating-characters/</link><pubDate>Tue, 10 Oct 2023 00:00:00 +0800</pubDate><guid>http://blog.weirwei.cn/leetcode/leetcode_longest-substring-without-repeating-characters/</guid><description>&lt;blockquote>
&lt;p>
&lt;a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/" title="https://leetcode.cn/problems/longest-substring-without-repeating-characters/" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
https://leetcode.cn/problems/longest-substring-without-repeating-characters/
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p></description></item></channel></rss>