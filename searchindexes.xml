<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>ã€leetcodeã€‘215. æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ </title><url>/post/leetcode/leetcode_kth-largest-element-in-an-array/</url><categories><category>leetcode</category></categories><tags><tag>æ¡¶æ’åº</tag></tags><content type="html"><![CDATA[   https://leetcode.cn/problems/kth-largest-element-in-an-array/ ç»™å®šæ•´æ•°æ•°ç»„ nums å’Œæ•´æ•° kï¼Œè¯·è¿”å›æ•°ç»„ä¸­ç¬¬ k ä¸ªæœ€å¤§çš„å…ƒç´ ã€‚
è¯·æ³¨æ„ï¼Œä½ éœ€è¦æ‰¾çš„æ˜¯æ•°ç»„æ’åºåçš„ç¬¬ k ä¸ªæœ€å¤§çš„å…ƒç´ ï¼Œè€Œä¸æ˜¯ç¬¬ k ä¸ªä¸åŒçš„å…ƒç´ ã€‚
ä½ å¿…é¡»è®¾è®¡å¹¶å®ç°æ—¶é—´å¤æ‚åº¦ä¸º O(n) çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜ã€‚
ç¤ºä¾‹ 1:
è¾“å…¥: [3,2,1,5,6,4], k = 2 è¾“å‡º: 5 ç¤ºä¾‹ 2: è¾“å…¥: [3,2,3,1,2,4,5,5,6], k = 4 è¾“å‡º: 4 æç¤ºï¼š
1 &lt;= k &lt;= nums.length &lt;= 10^5
-10^4 &lt;= nums[i] &lt;= 10^4
è§£é¢˜æ€è·¯ å…ˆè€ƒè™‘ä¸€ä¸‹éšè—æ¡ä»¶ï¼š å…ƒç´ å¯èƒ½ä¼šé‡å¤ é¦–å…ˆæƒ³åˆ°çš„ï¼Œå› ä¸º nums æ˜¯æ— åºçš„ï¼Œå› æ­¤è‡³å°‘éœ€è¦éå†ä¸€éï¼Œé¢˜ç›®è¦æ±‚ O(n) ï¼Œåˆ™è¡¨ç¤ºéœ€è¦åœ¨éå†çš„è¿‡ç¨‹ä¸­æ’å¥½åºã€‚è‡ªç„¶å°±æƒ³åˆ°äº†æ¡¶æ’åºã€‚ ä»£ç  func findKthLargest(nums []int, k int) int { bucket := make([]int, 20001) for _, v := range nums { bucket[v+10000]++ } count := len(bucket) - 1 for { if bucket[count] &gt; 0 { k = k - bucket[count] } if k &lt;= 0 { return count - 10000 } count-- } } åè®° çœ‹ä¸€çœ¼ç­”æ¡ˆï¼Œå±…ç„¶æ˜¯å¿«æ’ T_T ã€‚ä¸ªäººå…¶å®ä¸å–œæ¬¢ç”¨æ¡¶æ’åºï¼Œå› ä¸ºå—ä¸‹æ ‡çº¦æŸï¼Œä¸å¤Ÿæ³›ç”¨ï¼Œå¹¶ä¸”å®ƒçš„æ€æƒ³å¾ˆåˆ«æ‰­ï¼Œæ„Ÿè§‰å°±åƒä½¿ç”¨redisçš„æ—¶å€™kvåç€å­˜ã€‚
ä½†æ˜¯æ—¢ç„¶å·²ç»å†™äº†ï¼Œå¹¶ä¸”æ¼‚äº®åœ°é€šè¿‡äº†ï¼Œé‚£ä¹ˆå¿«æ’å…„ï¼Œä¸‹æ¬¡ä¸€å®šï¼æºœ~
  ]]></content></entry><entry><title>go ç»“æ„ä½“åŒ…å«æ¥å£æˆå‘˜è¿›è¡Œååºåˆ—åŒ–</title><url>/post/go_struct_contains_interface/</url><categories><category>å®æˆ˜é—®é¢˜</category></categories><tags><tag>golang</tag><tag>json</tag></tags><content type="html"><![CDATA[   å·¥ä½œä¸­é‡åˆ°ä¸€ä¸ªé—®é¢˜ï¼Œç»“æ„ä½“åŒ…å«æ¥å£ç±»å‹çš„æˆå‘˜æ—¶ï¼Œåœ¨ååºåˆ—åŒ–çš„æ—¶å€™ä¼šæŠ¥é”™ã€‚
// Task æ¥å£ç±»å‹ type Task interface { Exec() error } // TaskA Taskæ¥å£çš„å®ç°ç±»A type TaskA struct { A string `json:&#34;a&#34;` } func (ta *TaskA) Exec() error { fmt.Println(&#34;TaskA Exec&#34;) return nil } // TaskB Taskæ¥å£çš„å®ç°ç±»B type TaskB struct { B string `json:&#34;b&#34;` } func (tb *TaskB) Exec() error { fmt.Println(&#34;TaskB Exec&#34;) return nil } // MixedStruct ååºåˆ—åŒ–ç›®æ ‡ç»“æ„ä½“ type MixedStruct struct { Id uint64 `json:&#34;id&#34;` Task Task `json:&#34;task&#34;` } åœºæ™¯ è¿™ä¸ªç»“æ„ä½“åœ¨ååºåˆ—åŒ–çš„è¿‡ç¨‹ä¸­ä¼šæŠ¥é”™ã€‚
éœ€è¦ç»™æ¥å£èµ‹å€¼å…·ä½“çš„ç»“æ„ä½“æ‰èƒ½æ­£å¸¸ååºåˆ—åŒ–ã€‚
func TestUnmarshal(t *testing.T) { t.Run(&#34;å¸¦ Interface çš„ç»“æ„ä½“ååºåˆ—åŒ–&#34;, func(t *testing.T) { str := &#34;{\&#34;id\&#34;:1,\&#34;task\&#34;:{\&#34;a\&#34;:\&#34;a\&#34;}}&#34; var mixed MixedStruct err := jsoniter.UnmarshalFromString(str, &amp;mixed) assert.NotNil(t, err) t.Log(err) // json_jsoniter.MixedStruct.Task: decode non empty interface: can not unmarshal into nil, error found in #10 byte of ...|:1,&#34;task&#34;:{&#34;a&#34;:&#34;a&#34;}}|..., bigger context ...|{&#34;id&#34;:1,&#34;task&#34;:{&#34;a&#34;:&#34;a&#34;}}|... mixed.Task = &amp;TaskA{} err = jsoniter.UnmarshalFromString(str, &amp;mixed) assert.Nil(t, err) }) } è§£å†³æ–¹æ¡ˆ æ–¹æ¡ˆä¸€ ç›´æ¥å¹²æ‰é—®é¢˜ï¼Œä¸å­˜æ¥å£ï¼Œå­˜JSONå­—ç¬¦ä¸²ã€‚
ä¼˜ç‚¹ï¼šç®€å•ç²—æš´
ç¼ºç‚¹ï¼šå¿…é¡»åœ¨ä¸šåŠ¡ä¸­è§£æè¿™ä¸ªå­—æ®µï¼ŒåŠ å¤§äº†å¤æ‚åº¦ï¼Œå¢åŠ äº†é‡å¤å·¥ä½œã€‚
æ–¹æ¡ˆäºŒ åœ¨ä¸šåŠ¡ä¸­ç»™æ¥å£æˆå‘˜èµ‹å€¼ã€‚
å¦‚ï¼š
mixed.Task = &amp;TaskA{} _ = jsoniter.UnmarshalFromString(str, &amp;mixed) ä¼˜ç‚¹ï¼šç®€å•ç²—æš´
ç¼ºç‚¹ï¼šèµ‹å€¼æˆä¸ºå‰ç½®æ¡ä»¶ï¼Œä¸åŒäºæ­£å¸¸çš„ååºåˆ—åŒ–æ“ä½œï¼Œåœ¨å®é™…å·¥ç¨‹ä¸­å®¹æ˜“é—å¿˜ã€‚ä¸”åœ¨ååŒå¼€å‘æ—¶å¿…é¡»å’Œæ‰€æœ‰å¼€å‘æˆå‘˜åŒæ­¥ã€‚
æ–¹æ¡ˆä¸‰ å¢åŠ ä¸€ä¸ª taskType ç±»å‹ï¼Œæ¥è¡¨ç¤ºå®ç°å“ªä¸ªç»“æ„ä½“
å®ç° UnmarshalJSON å‡½æ•°
const ( TaskTypeA = 1 TaskTypeB = 2 ) type MixedStruct struct { Id uint64 `json:&#34;id&#34;` TaskType int `json:&#34;taskType&#34;` Task Task `json:&#34;task&#34;` } func (a *MixedStruct) UnmarshalJSON(b []byte) error { if a.Task == nil { // ç»™æ¥å£èµ‹å€¼å…·ä½“å®ç°ç±» taskType := jsoniter.Get(b, &#34;taskType&#34;) switch taskType.ToInt() { case TaskTypeA: a.Task = &amp;TaskA{} case TaskTypeB: a.Task = &amp;TaskB{} default: return errors.New(&#34;illegal task type&#34;) } } // ç»“æ„éœ€è¦è·ŸMixedStruct ä¿æŒä¸€è‡´ tmp := struct { Id uint64 `json:&#34;id&#34;` TaskType int `json:&#34;taskType&#34;` Task Task `json:&#34;task&#34;` }{} tmp.Task = a.Task if err := jsoniter.Unmarshal(b, &amp;tmp); err != nil { return err } a.Id = tmp.Id a.Task = tmp.Task a.TaskType = tmp.TaskType return nil } ä¼˜ç‚¹ï¼šå®Œç¾è§£å†³é—®é¢˜ï¼Œååºåˆ—åŒ–çš„æ—¶å€™ä¸éœ€è¦é¢å¤–æ“ä½œ
ç¼ºç‚¹ï¼šæœ‰ç»´æŠ¤æˆæœ¬ï¼Œéœ€è¦ç»´æŠ¤taskTypeçš„æšä¸¾å€¼ï¼Œä¸”åœ¨ç»™MixedStruct å¢åŠ å­—æ®µçš„æ—¶å€™å¿…é¡»å¯¹åº”ç»´æŠ¤UnmarshalJSONçš„å®ç°ã€‚
ä¸»è¦æ˜¯æƒ³ä»‹ç»è¿™ä¸ªæ–¹æ¡ˆä¸‰ï¼Œå¯¹äºå®ƒçš„ç¼ºç‚¹ï¼š
taskType è¿™ä¸ªå€¼åŸºæœ¬ä¸Šä¸è®ºæ˜¯å¦ç”¨æ¥å£æˆå‘˜ï¼Œéƒ½éœ€è¦ç»´æŠ¤ï¼Œæ²¡æœ‰å¢åŠ å®é™…æˆæœ¬ã€‚ å¯ä»¥æŠŠ MixedStruct å’Œ UnmarshalJSON æ”¾åœ¨ä¸€ä¸ªæ–‡ä»¶é‡Œï¼Œå¹¶åœ¨æ¥å£æˆå‘˜çš„åé¢åŠ ä¸Šå¯¹åº”æ³¨é‡Šï¼Œèµ·åˆ°å¤‡å¿˜å’Œæç¤ºçš„ä½œç”¨ã€‚ è¿˜æœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„ï¼Œåœ¨èµ‹å€¼ Task çš„æ—¶å€™ï¼Œä¸è¦ç”¨ä½¿ç”¨ç±»ä¼¼äº a.Task = b.Task ï¼Œå› ä¸º Task æ˜¯åœ°å€ç±»å‹ï¼Œä½¿ç”¨çš„æ˜¯åŒä¸€ç‰‡å†…å­˜ï¼Œä¿®æ”¹ a.Task çš„æ—¶å€™ï¼Œb.Task ä¹Ÿä¼šå—å½±å“ï¼Œå»ºè®®ç»™Task å¢åŠ ä¸€ä¸ª Copy() æ–¹æ³•ï¼Œå®ç°æ·±æ‹·è´ã€‚
  ]]></content></entry><entry><title>ã€leetcodeã€‘146. LRU ç¼“å­˜</title><url>/post/leetcode/leetcode_lru-cache/</url><categories><category>leetcode</category></categories><tags><tag>é“¾è¡¨</tag><tag>ç¼“å­˜</tag></tags><content type="html"><![CDATA[   https://leetcode.cn/problems/lru-cache è¯·ä½ è®¾è®¡å¹¶å®ç°ä¸€ä¸ªæ»¡è¶³ LRU (æœ€è¿‘æœ€å°‘ä½¿ç”¨) ç¼“å­˜ çº¦æŸçš„æ•°æ®ç»“æ„ã€‚
å®ç° LRUCache ç±»ï¼š
LRUCache(int capacity) ä»¥ æ­£æ•´æ•° ä½œä¸ºå®¹é‡ capacity åˆå§‹åŒ– LRU ç¼“å­˜ int get(int key) å¦‚æœå…³é”®å­— key å­˜åœ¨äºç¼“å­˜ä¸­ï¼Œåˆ™è¿”å›å…³é”®å­—çš„å€¼ï¼Œå¦åˆ™è¿”å› -1 ã€‚ void put(int key, int value) å¦‚æœå…³é”®å­— key å·²ç»å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶æ•°æ®å€¼ value ï¼›å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™å‘ç¼“å­˜ä¸­æ’å…¥è¯¥ç»„ key-value ã€‚å¦‚æœæ’å…¥æ“ä½œå¯¼è‡´å…³é”®å­—æ•°é‡è¶…è¿‡ capacity ï¼Œåˆ™åº”è¯¥ é€å‡º æœ€ä¹…æœªä½¿ç”¨çš„å…³é”®å­—ã€‚ å‡½æ•° get å’Œ put å¿…é¡»ä»¥ O(1) çš„å¹³å‡æ—¶é—´å¤æ‚åº¦è¿è¡Œã€‚ ç¤ºä¾‹ï¼š
è¾“å…¥ [&#34;LRUCache&#34;, &#34;put&#34;, &#34;put&#34;, &#34;get&#34;, &#34;put&#34;, &#34;get&#34;, &#34;put&#34;, &#34;get&#34;, &#34;get&#34;, &#34;get&#34;] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] è¾“å‡º [null, null, null, 1, null, -1, null, -1, 3, 4] è§£é‡Š LRUCache lRUCache = new LRUCache(2); lRUCache.put(1, 1); // ç¼“å­˜æ˜¯ {1=1} lRUCache.put(2, 2); // ç¼“å­˜æ˜¯ {1=1, 2=2} lRUCache.get(1); // è¿”å› 1 lRUCache.put(3, 3); // è¯¥æ“ä½œä¼šä½¿å¾—å…³é”®å­— 2 ä½œåºŸï¼Œç¼“å­˜æ˜¯ {1=1, 3=3} lRUCache.get(2); // è¿”å› -1 (æœªæ‰¾åˆ°) lRUCache.put(4, 4); // è¯¥æ“ä½œä¼šä½¿å¾—å…³é”®å­— 1 ä½œåºŸï¼Œç¼“å­˜æ˜¯ {4=4, 3=3} lRUCache.get(1); // è¿”å› -1 (æœªæ‰¾åˆ°) lRUCache.get(3); // è¿”å› 3 lRUCache.get(4); // è¿”å› 4 æç¤ºï¼š
1 &lt;= capacity &lt;= 3000 0 &lt;= key &lt;= 10000 0 &lt;= value &lt;= 105 æœ€å¤šè°ƒç”¨ 2 * 105 æ¬¡ get å’Œ put
è§£é¢˜æ€è·¯ å®ç°åŠŸèƒ½ ä¸»è¦åŠŸèƒ½æ˜¯ Get å’Œ Putï¼Œå…ˆåˆ†æä¸€ä¸‹è¿™ä¸¤ä¸ªæ–¹æ³•éœ€è¦å®ç°ä»€ä¹ˆåŠŸèƒ½
Get
è·å–ç¼“å­˜å€¼ æé«˜keyçš„ä¼˜å…ˆçº§ Put
key å·²å­˜åœ¨ è®¾ç½®ç¼“å­˜ è®¾ç½®å½“å‰key çš„ä¼˜å…ˆçº§ä¸ºæœ€é«˜ key ä¸å­˜åœ¨ è®¾ç½®ç¼“å­˜ è®¾ç½®å½“å‰key çš„ä¼˜å…ˆçº§ä¸ºæœ€é«˜ æ£€æŸ¥ç¼“å­˜å®¹é‡ æ•°æ®ç»“æ„ é¦–å…ˆæ˜¯ç¼“å­˜å†…å®¹ï¼Œä¾¿äºå­˜å–ï¼Œä½¿ç”¨map æœ€åˆé€‚
å…¶æ¬¡æ˜¯ä¼˜å…ˆçº§ï¼Œä»–éœ€è¦éœ€è¦æ”¯æŒ
å°†æŸä¸ªkeyçš„ä¼˜å…ˆçº§æåˆ°æœ€é«˜ åˆ é™¤ä¼˜å…ˆçº§æœ€ä½çš„key è¿™é‡Œå°±è€ƒè™‘åˆ°äº† åˆ‡ç‰‡ã€é“¾è¡¨
åˆ‡ç‰‡ï¼šåˆ é™¤key æ¯”è¾ƒæ–¹ä¾¿ã€‚ä½†æ˜¯å®šä½keyæ¥æå‡ä¼˜å…ˆçº§éœ€è¦ O(n) çš„å¤æ‚åº¦ é“¾è¡¨ï¼šåˆ é™¤key éœ€è¦çŸ¥é“è¡¨å°¾ï¼Œç”¨åŒå‘é“¾è¡¨ã€‚æå‡ä¼˜å…ˆçº§å°†å¯¹åº”çš„èŠ‚ç‚¹æåˆ°è¡¨å¤´å³å¯ã€‚åŒå‘é“¾è¡¨å®Œæˆè¿™ä¸¤ä¸ªèƒ½åŠ›çš„æˆæœ¬æ›´ä½ã€‚ ä»£ç  type Node struct { key, val int pre, next *Node } type LRUCache struct { m map[int]*Node // ç¼“å­˜æ˜ å°„ head, tail *Node // åŒå‘é“¾è¡¨ï¼Œç»´æŠ¤ä¼˜å…ˆçº§ï¼Œhead æŒ‡å‘ä¼˜å…ˆçº§æœ€é«˜ cap int // æœ€å¤§å®¹é‡ size int // å½“å‰ç¼“å­˜æ•°é‡ } func Constructor(capacity int) LRUCache { l := LRUCache{ m: make(map[int]*Node, capacity), head: &amp;Node{}, tail: &amp;Node{}, cap: capacity, } l.head.next = l.tail l.tail.pre = l.head return l } /* * Get è·å–ç¼“å­˜ 1. è·å–ç¼“å­˜å€¼ 2. æé«˜å½“å‰key çš„ä¼˜å…ˆçº§ */ func (this *LRUCache) Get(key int) int { node, ok := this.m[key] if ok { this.moveToHead(node) return node.val } return -1 } /* * Put è®¾ç½®ç¼“å­˜ ä¸¤ç§æƒ…å†µï¼š case1ï¼škey å·²å­˜åœ¨ 1. è®¾ç½®ç¼“å­˜ 2. æé«˜å½“å‰key çš„ä¼˜å…ˆçº§ case2: key ä¸å­˜åœ¨ 1. è®¾ç½®ç¼“å­˜ 2. åœ¨è¡¨å¤´æ’å…¥key 3. æ£€æŸ¥ç¼“å­˜å®¹é‡ */ func (this *LRUCache) Put(key int, value int) { node, ok := this.m[key] if ok { node.val = value this.moveToHead(node) } else { node = &amp;Node{ key: key, val: value, } this.m[key] = node this.addToHead(node) this.size++ } for this.size &gt; this.cap { tail := this.removeTail() delete(this.m, tail.key) this.size-- } } func (this *LRUCache) addToHead(node *Node) { node.pre = this.head node.next = this.head.next this.head.next.pre = node this.head.next = node } func (this *LRUCache) removeNode(node *Node) { node.pre.next = node.next node.next.pre = node.pre } func (this *LRUCache) moveToHead(node *Node) { this.removeNode(node) this.addToHead(node) } func (this *LRUCache) removeTail() *Node { node := this.tail.pre this.removeNode(node) return node }   ]]></content></entry><entry><title>ã€leetcodeã€‘206. åè½¬é“¾è¡¨</title><url>/post/leetcode/leetcode_reverse-linked-list/</url><categories><category>leetcode</category></categories><tags><tag>é“¾è¡¨</tag><tag>æ»‘åŠ¨çª—å£</tag></tags><content type="html"> https://leetcode.cn/problems/reverse-linked-list ç»™ä½ å•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ head ï¼Œè¯·ä½ åè½¬é“¾è¡¨ï¼Œå¹¶è¿”å›åè½¬åçš„é“¾è¡¨ã€‚
ç¤ºä¾‹ 1ï¼š
è¾“å…¥ï¼šhead = [1,2,3,4,5] è¾“å‡ºï¼š[5,4,3,2,1] ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼šhead = [1,2] è¾“å‡ºï¼š[2,1] ç¤ºä¾‹ 3ï¼š
è¾“å…¥ï¼šhead = [] è¾“å‡ºï¼š[] æç¤ºï¼š
é“¾è¡¨ä¸­èŠ‚ç‚¹çš„æ•°ç›®èŒƒå›´æ˜¯ [0, 5000] -5000 &amp;lt;= Node.val &amp;lt;= 5000
è¿›é˜¶ï¼šé“¾è¡¨å¯ä»¥é€‰ç”¨è¿­ä»£æˆ–é€’å½’æ–¹å¼å®Œæˆåè½¬ã€‚ä½ èƒ½å¦ç”¨ä¸¤ç§æ–¹æ³•è§£å†³è¿™é“é¢˜ï¼Ÿ
è§£é¢˜æ€è·¯ æ–¹æ¡ˆä¸€
éå†å…¥å †æ ˆï¼Œå†è¯»ä¸€é æ–¹æ¡ˆäºŒ
ç›´æ¥è°ƒè½¬æŒ‡å‘ï¼Œç”¨ä¸´æ—¶èŠ‚ç‚¹è®°å½•ä¸­é—´å€¼ æ–¹æ¡ˆä¸‰
é€’å½’å›æº¯ è¿™ä¸ªæ–¹æ¡ˆæ²¡æƒ³åˆ°ï¼Œåˆ©ç”¨é€’å½’ä»é“¾è¡¨å°¾å›æº¯åˆ°é“¾è¡¨å¤´ï¼Œå®Œæˆç¿»è½¬ æœ¬ç€åšé¢˜çš„ç›®çš„ï¼Œæˆ‘çš„codingæ˜¯æ–¹æ¡ˆäºŒã€‚å…¶å®å®é™…å¼€å‘ä¸­é‡åˆ°ç±»ä¼¼çš„é—®é¢˜ï¼Œæ€§èƒ½å†…å­˜ä¸æ˜¯ç“¶é¢ˆçš„æƒ…å†µä¸‹ï¼Œæˆ‘ä¼šæ¯«ä¸çŠ¹è±«åœ°é€‰æ‹©æ–¹æ¡ˆä¸€ã€‚å¯è¯»æ€§é«˜ï¼Œè€Œä¸”ä¸å®¹æ˜“å‡ºé”™ã€‚
ä»£ç  func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } var target, mid1, mid2 *ListNode mid1, mid2 = head, head.Next for mid2 != nil { mid2 = mid1.Next mid1.Next = target target = mid1 mid1 = mid2 } return target }</content></entry><entry><title>ã€leetcodeã€‘3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²</title><url>/post/leetcode/leetcode_longest-substring-without-repeating-characters/</url><categories><category>leetcode</category></categories><tags><tag>é˜Ÿåˆ—</tag><tag>æ»‘åŠ¨çª—å£</tag></tags><content type="html"><![CDATA[   https://leetcode.cn/problems/longest-substring-without-repeating-characters/ ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² s ï¼Œè¯·ä½ æ‰¾å‡ºå…¶ä¸­ä¸å«æœ‰é‡å¤å­—ç¬¦çš„ æœ€é•¿å­ä¸² çš„é•¿åº¦ã€‚
ç¤ºä¾‹ 1:
è¾“å…¥: s = &#34;abcabcbb&#34; è¾“å‡º: 3 è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ &#34;abc&#34;ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 3ã€‚ ç¤ºä¾‹ 2:
è¾“å…¥: s = &#34;bbbbb&#34; è¾“å‡º: 1 è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ &#34;b&#34;ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 1ã€‚ ç¤ºä¾‹ 3:
è¾“å…¥: s = &#34;pwwkew&#34; è¾“å‡º: 3 è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ &#34;wke&#34;ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 3ã€‚ è¯·æ³¨æ„ï¼Œä½ çš„ç­”æ¡ˆå¿…é¡»æ˜¯ å­ä¸² çš„é•¿åº¦ï¼Œ&#34;pwke&#34; æ˜¯ä¸€ä¸ªå­åºåˆ—ï¼Œä¸æ˜¯å­ä¸²ã€‚ æç¤ºï¼š
0 &lt;= s.length &lt;= 5 * 104 s ç”±è‹±æ–‡å­—æ¯ã€æ•°å­—ã€ç¬¦å·å’Œç©ºæ ¼ç»„æˆ è§£é¢˜æ€è·¯ æœ¬é¢˜æ±‚çš„æ˜¯å­åºåˆ—ï¼Œæ˜¯è¿ç»­çš„ï¼Œå› æ­¤å¯ä»¥åˆ©ç”¨æ»‘åŠ¨çª—å£çš„æ€æƒ³å’Œé˜Ÿåˆ—çš„æ•°æ®ç»“æ„ã€‚ å­åºåˆ—éœ€è¦æ»¡è¶³ä¸é‡å¤çš„è§„åˆ™ï¼Œå¯ä»¥éå†å­—ç¬¦ä¸²ï¼Œé‡åˆ°é‡å¤çš„å­—ç¬¦ä¸¢å¼ƒå‰ä¸€ä¸ªè¯¥å­—ç¬¦åŠå…¶ä»¥å‰çš„éƒ¨åˆ†ï¼Œæ¯æ¬¡æ»‘åŠ¨éƒ½è®°å½•é•¿åº¦ã€‚ ä»£ç  func lengthOfLongestSubstring(s string) int { var max int m := make(map[rune]struct{}) var queue []rune for _, v := range s { if _, ok := m[v]; ok { for len(queue) &gt; 0 &amp;&amp; queue[0] != v { delete(m, queue[0]) queue = queue[1:] } delete(m, queue[0]) queue = queue[1:] } m[v] = struct{}{} queue = append(queue, v) if len(queue) &gt; max { max = len(queue) } } return max }   ]]></content></entry><entry><title>MySQL where èŒƒå›´æŸ¥è¯¢å’Œ order by å…³é”®å­—æ— æ³•åŒæ—¶å‘½ä¸­ç´¢å¼•</title><url>/post/index_in_orderby/</url><categories><category>å®æˆ˜é—®é¢˜</category></categories><tags><tag>MySQL</tag><tag>ç´¢å¼•</tag></tags><content type="html"><![CDATA[   å¼€å‘ä¸­ï¼Œä½¿ç”¨ in å’Œ order by çš„æ—¶å€™ï¼Œå‘ç°æ— æ³•åŒæ—¶å‘½ä¸­ç´¢å¼•ã€‚
ä½¿ç”¨ IN è¿ç®—ç¬¦æ¥è¿‡æ»¤è¡Œæ—¶ï¼ŒMySQL ä¼šå…ˆä½¿ç”¨ç´¢å¼•æ¥å®šä½è¡¨ä¸­çš„è¡Œï¼Œå¹¶å°†è¿™äº›è¡Œçš„æ‰€æœ‰æ•°æ®è¯»å…¥å†…å­˜ä¸­ã€‚éšåï¼ŒMySQL ä¼šæ ¹æ®æŸ¥è¯¢è¯­å¥ä¸­çš„ ORDER BY å­å¥å¯¹è¿™äº›æ•°æ®è¿›è¡Œæ’åºã€‚
ç®€å•åœºæ™¯æ„é€  CREATE TABLE `c` ( `id` bigint unsigned NOT NULL AUTO_INCREMENT, `a` int NOT NULL DEFAULT &#39;0&#39;, `b` int NOT NULL DEFAULT &#39;0&#39;, `c` int NOT NULL DEFAULT &#39;0&#39;, PRIMARY KEY (`id`), KEY `abc` (`a`,`b`,`c`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci -- data insert into c(a, b, c) values (1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 2, 1), (1, 2, 2), (1, 2, 3), (1, 2, 3), (2, 2, 2), (3, 3, 3); Explain SELECT éèŒƒå›´æŸ¥è¯¢ explain select * from c where a = 1 and b = 1 order by c; /* +----+-------------+-------+------------+------+---------------+------+---------+-------------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+-------------+------+----------+-------------+ | 1 | SIMPLE | c | NULL | ref | abc | abc | 8 | const,const | 3 | 100.00 | Using index | +----+-------------+-------+------------+------+---------------+------+---------+-------------+------+----------+-------------+ */ èƒ½å¤Ÿå®Œç¾å‘½ä¸­ç´¢å¼•ã€‚
èŒƒå›´æŸ¥è¯¢ explain select * from c where a = 1 and b &gt; 1 order by c; /* +----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+------------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+------------------------------------------+ | 1 | SIMPLE | c | NULL | range | abc | abc | 8 | NULL | 4 | 100.00 | Using where; Using index; Using filesort | +----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+------------------------------------------+ */ èŒƒå›´æŸ¥è¯¢ç”¨åˆ°äº†filesortï¼Œè¡¨ç¤º order byæ²¡æœ‰å‘½ä¸­ç´¢å¼•ï¼Œabc ç´¢å¼•çš„ä½œç”¨ç›¸å½“äº abã€‚
ç´¢å¼•åˆ†æ ç´¢å¼•ç»“æ„
a b c 1 1 1 2 3 2 1 2 3 3 2 2 2 3 3 3 select * from c where a = 1 and b = 1 order by c; åœ¨éèŒƒå›´æŸ¥è¯¢çš„æ—¶å€™ï¼Œå¯ä»¥å‘ç°ï¼Œç»è¿‡whereè¯­å¥ï¼Œcçš„èŒƒå›´æ˜¯ 1ã€2ã€3ï¼Œbå·²ç¡®å®šï¼Œc æœ‰åºï¼Œorder by å¯ä»¥å‘½ä¸­ç´¢å¼•ã€‚
select * from c where a = 1 and b &gt; 1 order by c; åœ¨èŒƒå›´æŸ¥è¯¢çš„æ—¶å€™ï¼Œç»è¿‡whereè¯­å¥ï¼Œcçš„èŒƒå›´æ˜¯ 1ã€2ã€3ã€1ã€2ã€3ã€3ï¼Œbæ— æ³•ç¡®å®šï¼ˆå¯èƒ½ä¸º1æˆ–2ï¼‰ï¼Œc ä¸ºæ— åºï¼Œorder by æ— æ³•å‘½ä¸­ç´¢å¼•ã€‚
  ]]></content></entry><entry><title>Gorm çš„é»‘é­”æ³•</title><url>/post/gorm_black_magic/</url><categories><category>å®æˆ˜é—®é¢˜</category></categories><tags><tag>golang</tag><tag>gorm</tag></tags><content type="html"><![CDATA[   å°ä¼™çœ‹åˆ°åŒäº‹å†™çš„Gormé»‘é­”æ³•ï¼Œé€æ¸ä¸æ·¡å®šäº†ã€‚
å¼€å‘è¿‡ç¨‹ä¸­ï¼Œçœ‹åˆ°åŒäº‹çš„ä»£ç å†™äº†è¿™ä¹ˆä¸€æ®µï¼š
db = db.Session(&amp;amp;gorm.Session{Context: db.Statement.Context}).FirstOrCreate(&amp;amp;entity) if db.Error !=nil{ return components.ErrorDbInsert.WrapPrintf(db.Error, &amp;#34;Insert error, entity:%s&amp;#34;, utils.ToJson(entity)) } if db.RowsAffected == 0 { return components.ErrorAlreadyExist } FirstOrCreate æˆ‘ä¸ç¦æ„Ÿåˆ°ç–‘æƒ‘ï¼Œgorm çš„ RowsAffected åœ¨è¿›è¡ŒæŸ¥è¯¢ï¼Œå¦‚æœæŸ¥åˆ°æ•°æ®ï¼Œä¹Ÿæ˜¯æœ‰å€¼çš„ï¼Œä¸ºä»€ä¹ˆåœ¨è¿™é‡Œå¯ä»¥ç”¨ RowsAffected == 0 æ¥åˆ¤æ–­æ•°æ®å·²å­˜åœ¨ï¼Ÿ
æŠ±ç€è¿™ä¸ªç–‘é—®ï¼Œæˆ‘ç‚¹å¼€äº† FirstOrCreate çš„ä»£ç ï¼š
func (db *DB) FirstOrCreate(dest interface{}, conds ...interface{}) (tx *DB) { queryTx := db.Limit(1).Order(clause.OrderByColumn{ Column: clause.Column{Table: clause.CurrentTable, Name: clause.PrimaryKey}, }) if tx = queryTx.Find(dest, conds...); queryTx.RowsAffected == 0 { ... return tx.Create(dest) } else if len(db.Statement.assigns) &amp;gt; 0 { ... return tx.Model(dest).Updates(assigns) } return db } æˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“åœ°å‘ç°ï¼Œåœ¨ Find æŸ¥åˆ°æ•°æ®ä¸” assigns æ²¡æœ‰å€¼çš„æƒ…å†µä¸‹ï¼Œreturn çš„æ˜¯ dbï¼Œè€Œå…¶ä»–æƒ…å†µä¸‹ return çš„æ˜¯ txã€‚ç›´è§‰å‘Šè¯‰æˆ‘ï¼ŒåŸå› å¤§æ¦‚ç‡åœ¨è¿™ä¸ªä¸Šé¢ã€‚
getInstance() Limitã€Orderã€Findç­‰è®¸å¤šå‡½æ•°éƒ½è°ƒç”¨äº†åŒä¸€ â€¦  ]]></content></entry><entry><title>MySQL ç´¢å¼•æ’åº</title><url>/post/mysql_index_sort/</url><categories><category>å­˜å‚¨</category></categories><tags><tag>MySQL</tag><tag>ç´¢å¼•</tag></tags><content type="html"> å¼€å‘è¿‡ç¨‹ä¸­å‘ç°SQLä¸€ç›´filesortï¼Œæ‰€ä»¥ç ”ç©¶ä¸€ä¸‹åˆ°ä½æ€ä¹ˆæ‰èƒ½ä½¿ç”¨ç´¢å¼•è¿›è¡Œæ’åºã€‚
è¡¨ç»“æ„å’Œæ•°æ® CREATE TABLE `t1` ( `id` int(11) NOT NULL AUTO_INCREMENT, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, `c` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `idx_a_b_c` (`a`,`b`,`c`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; id a b c 1 1 5 3 2 5 3 3 3 4 5 9 4 2 6 1 5 4 3 2 6 5 5 5 7 1 2 1 8 5 5 8 9 5 3 9 10 5 5 1 11 5 7 7 SQL explain select * from t where a = 5 order by c desc; -- type:ref -- key:idx_a_b_c -- ref:const -- Extra:Using where; Using index; Using filesort explain select * from t where a = 5 order by b desc; -- type:ref -- key:idx_a_b_c -- ref:const -- Extra:Using where; Using index explain select * from t where a = 5 and c = 5 order by b desc; -- type:ref -- key:idx_a_b_c -- ref:const -- Extra:Using where; Using index explain select * from t where a = 5 and b = 5 order by c desc; -- type:ref -- key:idx_a_b_c -- ref:const,const -- Extra:Using where; Using index explain select * from t where a = 5 and b &amp;gt;= 5 order by c desc; -- type:range -- key:idx_a_b_c -- ref:NULL -- Extra:Using where; Using index; Using filesort ç´¢å¼•åˆ†æ é€šè¿‡è§‚å¯Ÿè”åˆç´¢å¼•çš„æ•°æ®ç»“æ„ï¼Œå¾ˆæ˜æ˜¾å°±èƒ½å‘ç°ç´¢å¼•éƒ½æ˜¯æœ‰åºçš„ï¼Œä½¿ç”¨ç´¢å¼•è¿›è¡Œæ’åºå°±æ˜¯åˆ©ç”¨äº†è¿™ä¸ªç‰¹æ€§ã€‚
æˆ‘ä»¬æ¥è§‚å¯Ÿ a = 5 çš„è¿™ä¸€æ®µç´¢å¼•ï¼Œå¾ˆå®¹æ˜“å°±èƒ½å‘ç°ï¼Œåœ¨ a ç¡®å®šçš„æƒ…å†µä¸‹ï¼Œb æ˜¯æœ‰åºçš„ï¼Œä½†c æ˜¯æ— åºçš„ã€‚a å’Œ b å‘½ä¸­ç´¢å¼•ï¼Œa å’Œ c ä¸å‘½ä¸­ç´¢å¼•
åœ¨ a,b éƒ½ç¡®å®šçš„æƒ…å†µä¸‹ï¼Œc æ˜¯æœ‰åºçš„ã€‚a,b,c å‘½ä¸­ç´¢å¼•
è¿™å°±æ˜¯è€ç”Ÿå¸¸è°ˆçš„ æœ€ä½³å·¦å‰ç¼€åŸåˆ™ ä¹Ÿå« æœ€å·¦å‰ç¼€åŒ¹é…åŸåˆ™
å› æ­¤ï¼Œè¦è®©æ’åºé¡¹ä½¿ç”¨ç´¢å¼•è¿›è¡Œæ’åº
ç¬¬ä¸€ä¸ªæ¡ä»¶å°±æ˜¯ï¼šwhereæ¡ä»¶+æ’åºé¡¹ç¬¦åˆæœ€ä½³å·¦å‰ç¼€åŸåˆ™
ç¬¬äºŒä¸ªæ¡ä»¶ï¼šä¸èƒ½ä½¿ç”¨æ¡ä»¶æŸ¥è¯¢
è¿™ä¸ªä¹Ÿå¯ä»¥é€šè¿‡è§‚å¯Ÿè”åˆç´¢å¼•å¾—å‡ºç»“è®º
a = 5 AND b &amp;gt;= 5 æ˜¾ç„¶æ˜¯æ— æ³•ä¿è¯ c æ˜¯æœ‰åºçš„
ç»“è®º è¦è®©order by ä½¿ç”¨ç´¢å¼•æ’åºï¼Œéœ€è¦è‡³å°‘æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š
whereæ¡ä»¶+æ’åºé¡¹ç¬¦åˆæœ€ä½³å·¦å‰ç¼€åŸåˆ™ ä¸èƒ½ä½¿ç”¨æ¡ä»¶æŸ¥è¯¢</content></entry><entry><title>go çš„åˆ‡ç‰‡æ‰©å®¹</title><url>/post/slice_expand/</url><categories><category>è¯­è¨€å­¦ä¹ </category></categories><tags><tag>golang</tag></tags><content type="html"><![CDATA[   åœ¨uber çš„goè¯­è¨€ç¼–ç è§„èŒƒä¸­æœ‰è¿™ä¹ˆä¸€æ¡ï¼Œ2.48s å’Œ0.21s çš„å·®è·è¿˜æ˜¯å¾ˆæƒŠäººäº†ï¼Œæˆ‘å¾ˆå¥½å¥‡ï¼Œwhyï¼Ÿ
åˆ‡ç‰‡åœ¨appendçš„æ—¶å€™å¯èƒ½ä¼šè‡ªåŠ¨æ‰©å®¹ï¼Œçœ‹ä¸€ä¸‹ç›¸å…³æºç ã€‚
slice type slice struct { array unsafe.Pointer len int cap int } func makeslice(et *_type, len, cap int) unsafe.Pointer { // 1. è®¡ç®—éœ€è¦ç”³è¯·çš„å®¹é‡ï¼Œå¹¶åˆ¤æ–­æ˜¯å¦å†…å­˜æº¢å‡º mem, overflow := math.MulUintptr(et.size, uintptr(cap)) // 2. å†…å­˜æº¢å‡ºåŸå›  if overflow || mem &gt; maxAlloc || len &lt; 0 || len &gt; cap { // è®¡ç®—sliceæ‰€éœ€å†…å­˜é€šè¿‡MulUintptræ¥å®ç°çš„ mem, overflow := math.MulUintptr(et.size, uintptr(len)) if overflow || mem &gt; maxAlloc || len &lt; 0 { panicmakeslicelen() } panicmakeslicecap() } // 3. è¿›è¡Œå†…å­˜åˆ†é… return mallocgc(mem, et, true) } func growslice(et *_type, old slice, cap int) slice { ... newcap := old.cap doublecap := newcap + newcap if cap &gt; doublecap { newcap = cap } else { // å½“åŸåˆ‡ç‰‡é•¿åº¦å°äº1024æ—¶ï¼Œæ–°åˆ‡ç‰‡çš„å®¹é‡ä¼šç›´æ¥ç¿»å€ã€‚è€Œå½“åŸåˆ‡ç‰‡çš„å®¹é‡å¤§äºç­‰äº1024æ—¶ï¼Œä¼šåå¤åœ°å¢åŠ 25%ï¼Œç›´åˆ°æ–°å®¹é‡è¶…è¿‡æ‰€éœ€è¦çš„å®¹é‡ if old.cap &lt; 1024 { newcap = doublecap } else { for 0 &lt; newcap &amp;&amp; newcap &lt; cap { newcap += newcap / 4 } if newcap &lt;= 0 { newcap = cap } } } var overflow bool var lenmem, newlenmem, capmem uintptr switch { case et.size == 1: lenmem = uintptr(old.len) newlenmem = uintptr(cap) capmem = roundupsize(uintptr(newcap)) overflow = uintptr(newcap) &gt; maxAlloc newcap = int(capmem) case et.size == sys.PtrSize: lenmem = uintptr(old.len) * sys.PtrSize newlenmem = uintptr(cap) * sys.PtrSize capmem = roundupsize(uintptr(newcap) * sys.PtrSize) overflow = uintptr(newcap) &gt; maxAlloc/sys.PtrSize newcap = int(capmem / sys.PtrSize) case isPowerOfTwo(et.size): var shift uintptr if sys.PtrSize == 8 { // Mask shift for better code generation. shift = uintptr(sys.Ctz64(uint64(et.size))) &amp; 63 } else { shift = uintptr(sys.Ctz32(uint32(et.size))) &amp; 31 } lenmem = uintptr(old.len) &lt;&lt; shift newlenmem = uintptr(cap) &lt;&lt; shift capmem = roundupsize(uintptr(newcap) &lt;&lt; shift) overflow = uintptr(newcap) &gt; (maxAlloc &gt;&gt; shift) newcap = int(capmem &gt;&gt; shift) default: lenmem = uintptr(old.len) * et.size newlenmem = uintptr(cap) * et.size capmem, overflow = math.MulUintptr(et.size, uintptr(newcap)) capmem = roundupsize(capmem) newcap = int(capmem / et.size) } ... } package runtime // å†…å­˜å¯¹é½çš„è¿‡ç¨‹ï¼Œä¸ºäº†é¿å…é€ æˆè¿‡å¤šçš„å†…å­˜ç¢ç‰‡ func roundupsize(size uintptr) uintptr { // size=1600*8=12800&lt;32768 if size &lt; _MaxSmallSize { // 12800&lt;=0 if size &lt;= smallSizeMax-8 { return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]]) } else { return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])//size_to_class128[92]= 56 //class_to_size[56]=13568 //13568/8=1696 } } if size+_PageSize &lt; size { return size } return round(size, _PageSize) } const _MaxSmallSize = 32768 const smallSizeDiv = 8 const smallSizeMax = 1024 const largeSizeDiv = 128 æ€»ç»“ sliceå®¹é‡çš„æ‰©å®¹è§„åˆ™ï¼šå½“åŸsliceçš„capå°äº1024æ—¶ï¼Œæ–°sliceçš„capå˜ä¸ºåŸæ¥çš„2å€ï¼›åŸsliceçš„capå¤§äº1024æ—¶ï¼Œæ–°sliceå˜ä¸ºåŸæ¥çš„1.25å€ï¼ŒæŒ‰ç…§è¿™ä¸ªè§„åˆ™æ‰©å……åï¼Œè¿˜ä¼šè¿›è¡Œå†…å­˜å¯¹é½æ“ä½œã€‚
å›åˆ°å¼€å¤´ï¼Œä¸ºä»€ä¹ˆç¡®å®šåˆ‡ç‰‡å®¹é‡çš„ç¨‹åºæ•ˆç‡æ›´é«˜ï¼Ÿå› ä¸ºä»–çœå»äº†æ‰©å®¹çš„æ­¥éª¤ã€‚
æ‰©å±•ï¼šå†…å­˜å¯¹é½çš„ç›®çš„ å‡è®¾CPUçš„å†…å­˜è¯»å†™å•ä½ä¸º4å­—èŠ‚
åœ¨å†…å­˜å¯¹é½å’Œéå¯¹é½æƒ…å†µä¸‹ï¼Œè¯»å–å˜é‡aéƒ½ä»…éœ€è¦è¯»å–ä¸€æ¬¡ã€‚
åœ¨å†…å­˜å¯¹é½æƒ…å†µä¸‹ï¼Œå¦‚æœè¦è¯»å–å˜é‡bï¼Œåˆ™ä»…éœ€è¦è¯»å–1æ¬¡ï¼Œå³ç¬¬äºŒéƒ¨åˆ†ï¼ˆ4-7ï¼‰ï¼›è€Œéå¯¹é½æƒ…å†µä¸‹ï¼Œåˆ™éœ€è¦è¯»å–2æ¬¡ï¼Œå³ç¬¬ä¸€éƒ¨åˆ†ï¼ˆ0-3ï¼‰å–å3ä¸ªå­—èŠ‚ï¼Œç¬¬äºŒéƒ¨åˆ†å–å‰1ä¸ªå­—èŠ‚ï¼Œç„¶åç”¨æˆ–æ“ä½œæ‹¼æ¥æˆå˜é‡bã€‚
å› æ­¤ï¼Œå†…å­˜å¯¹é½åœ¨æŸäº›æƒ…å†µä¸‹å¯ä»¥å‡å°‘å†…å­˜çš„è¯»å–æ¬¡æ•°ï¼Œæé«˜æ€§èƒ½ï¼Œæ˜¯ä¸€ç§ç©ºé—´æ¢æ—¶é—´çš„ç­–ç•¥ã€‚
  ]]></content></entry><entry><title>go test çš„å†…è”é—®é¢˜</title><url>/post/inlining/</url><categories><category>å®æˆ˜é—®é¢˜</category></categories><tags><tag>golang</tag><tag>test</tag></tags><content type="html"><![CDATA[   ä½¿ç”¨monkeyå¯¹å‡½æ•°è¿›è¡Œæ‰“æ¡©å•æµ‹çš„æ—¶å€™ï¼Œå‘ç°æ‰“æ¡©å‡½æ•°æ²¡æœ‰ç”Ÿæ•ˆã€‚
ä¹ æƒ¯ç›´æ¥ä½¿ç”¨IDEçš„å¯è§†åŒ–çš„runå’ŒdebugåŠŸèƒ½è¿›è¡Œè·‘å•æµ‹ï¼Œæ²¡æœ‰å…³æ³¨åˆ°å…·ä½“æ‰§è¡Œçš„å‘½ä»¤ã€‚
å•æµ‹ä»£ç  func TestLogin(t *testing.T) { // åˆå§‹åŒ– dao å±‚ userDao := &amp;daoUser.UserDao{} // åˆå§‹åŒ– service å±‚ entity := &amp;LoginService{} Convey(&#34;GetUserByUsername&#34;, t, func() { Convey(&#34;Should be success&#34;, func() { // ç»™ GetByUsername å‡½æ•°æ‰“æ¡©ï¼ŒæŒ‡å®šè¿”å›å€¼ patches := ApplyMethod(reflect.TypeOf(UserDao), &#34;GetByUsername&#34;, func(*daoUser.UserDao, string) (*daoUser.User, error) { return &amp;daoUser.User{ ID: 1, Username: &#34;weirwei&#34;, Password: &#34;123456&#34;, }, nil }) defer patches.Reset() // æµ‹è¯• Login res, err := entity.Login(&#34;weirwei&#34;, &#34;123456&#34;) // æ–­è¨€ So(err, ShouldBeNil) So(res, ShouldBeTrue) }) }) } é—®é¢˜åˆ†æ æŸ¥çœ‹runå’Œdebugçš„å‘½ä»¤
# run /usr/local/go/bin/go test -c -o /private/var/folders/1q/llslx_n95d1brs7hq2drxjjw0000gn/T/___1go_test_gin_study_service_svUser gin-study/service/svUser # debug /usr/local/go/bin/go test -c -o /private/var/folders/1q/llslx_n95d1brs7hq2drxjjw0000gn/T/___go_test_gin_study_service_svUser -gcflags all=-N -l gin-study/service/svUser å¾ˆæ˜æ˜¾å°±èƒ½å‘ç°debugæ¯”runå¤šäº† -gcflags all=-N -lï¼Œè¿™ä¸ªå°±æ˜¯==ç¦ç”¨å†…è”==çš„é€‰é¡¹
å†…è”(inlining)ï¼šç²—æš´çš„æ¥è¯´ï¼Œå°±æ˜¯å°†å‡½æ•°å†…å®¹å¤åˆ¶åˆ°å‡½æ•°è°ƒç”¨çš„åœ°æ–¹ï¼Œ==å‡å°‘äº†å‡½æ•°è°ƒç”¨çš„å¼€æ”¯==ï¼Œä½†ä¸€å®šç¨‹åº¦ä¸Šä¼šå¢åŠ ç¨‹åºçš„ä»£ç é‡ï¼Œ==å ç”¨æ›´å¤šçš„å†…å­˜==ã€‚
è¿™ä¹ˆçœ‹å°±å¾ˆæ˜æ˜¾äº†ï¼Œæœ¬æ¥æ‰“æ¡©å GetUserByUsername ä¼šç›´æ¥è¿”å›ç»™å®šçš„ç»“æœï¼Œä¸èµ° dao å±‚çš„å®é™…ä»£ç ï¼Œä½†æ˜¯ go åœ¨ç¼–è¯‘è¿‡ç¨‹ä¸­ä¼šè¿›è¡Œå†…è”ä¼˜åŒ–ï¼Œå°† dao å±‚çš„ä»£ç ç›´æ¥â€œå¤åˆ¶â€è¿‡æ¥ï¼Œç»•è¿‡äº†æµ‹è¯•æ¡©ã€‚è€Œåœ¨æœ¬æ®µæµ‹è¯•ä»£ç ä¸­å¹¶æ²¡æœ‰å¯¹ dao å±‚è¿›è¡Œç›¸å…³é…ç½®åŠåˆå§‹åŒ–ï¼Œå¯¼è‡´ä»£ç åœ¨æ‰§è¡Œæ—¶å‡ºç°é”™è¯¯ã€‚
  ]]></content></entry><entry><title>Typora + PicGo + Gitee è§£æ”¾ä½ å¯¹å›¾ç‰‡çš„ç®¡ç†</title><url>/post/typora+picgo+gitee/</url><categories><category>å®ç”¨å·¥å…·</category></categories><tags><tag>Markdown</tag><tag>å›¾åºŠ</tag></tags><content type="html"> ä½¿ç”¨markdownåšç¬”è®°çš„æ—¶å€™ï¼Œä½¿ç”¨å›¾ç‰‡æ—¶ï¼Œéœ€è¦å°†å›¾ç‰‡æ”¾åœ¨æŒ‡å®šæ–‡ä»¶å¤¹ï¼Œç„¶åå¼•ç”¨ã€‚è¿™ä¹ˆåšæ¯æ¬¡æ·»åŠ å›¾ç‰‡éƒ½æ¯”è¾ƒå›°éš¾ï¼Œå¹¶ä¸”ä¸ä¾¿äºå¤šç«¯ä½¿ç”¨ã€‚
ä½¿ç”¨PicGoä½œä¸ºå›¾åºŠï¼Œå°†å›¾ç‰‡æ‰˜ç®¡åˆ°Giteeï¼Œåœ¨ä½¿ç”¨Typoraåšç¬”è®°çš„æ—¶å€™å¯ä»¥ç›´æ¥æ— ç¼ä¸Šä¼ å›¾ç‰‡ã€‚
è®¡ç®—æœºç¯å¢ƒå‡†å¤‡ Typora PicGo nodejs Typoraå®˜ç½‘: https://typora.io/ PicGoå®˜ç½‘: https://picgo.github.io/PicGo-Doc/zh/guide/ nodejsä¸‹è½½åœ°å€: http://nodejs.cn/download/ è®¾ç½® Gitee ä½œä¸º PicGo çš„é»˜è®¤å›¾åºŠ åœ¨ PicGo å®‰è£… gitee æ’ä»¶ åœ¨æ’ä»¶è®¾ç½®æœç´¢giteeï¼Œé€‰æ‹©å…¶ä¸­ä¸€ä¸ªå®‰è£…(ä¸¤ä¸ªéƒ½å¯ä»¥ï¼Œåªæ˜¯é…ç½®å†…å®¹æœ‰ç¨è®¸ä¸åŒ)
åœ¨ Gitee åˆ›å»ºå›¾ç‰‡ä»“åº“ æ³¨æ„==ä»“åº“å¿…é¡»å…¬å¼€å¹¶ä¸”ä½¿ç”¨Readmeåˆå§‹åŒ–==
è¿›è¡Œå›¾åºŠé…ç½® è‹¥åœ¨å›¾åºŠè®¾ç½®ä¸­æœªæ‰¾åˆ° Gitee å›¾åºŠï¼Œé‡å¯ PicGo å³å¯
owner: Gitee ç”¨æˆ·å repo: Gitee ä»“åº“å path: Gitee å­˜æ”¾å›¾ç‰‡çš„æ–‡ä»¶å¤¹è·¯å¾„ token: Gitee ç§äººä»¤ç‰Œ message: commit ä¿¡æ¯ ç”Ÿæˆç§äººä»¤ç‰Œ: è®¾ç½®-&amp;gt; ç§äººä»¤ç‰Œ -&amp;gt; ç”Ÿæˆæ–°ä»¤ç‰Œ
åªå‹¾é€‰ projects å³å¯
æäº¤åå¤åˆ¶ token è‡³ PicGo å³å¯
å¯åœ¨ä¸Šä¼ åŒºè¿›è¡Œæµ‹è¯•
é…ç½® Typora ä¸Šä¼ æœåŠ¡ ç„¶åå¼€å§‹æ„‰å¿«åœ° Markdown å§ï¼</content></entry><entry><title>å…³äº Hugo NexT ç»„ç»‡</title><url>/about.html</url><categories/><tags/><content type="html"> Hugo NexT ç»„ç»‡æ˜¯ç”±ä¼—å¤šå–œçˆ± NexT ä¸»é¢˜åŠé£æ ¼çš„ä¸–ç•Œå„åœ°å‹äººå…±åŒç»„å»ºè€Œæˆï¼Œä¸ºçš„å°±æ˜¯è®©è¿™ä¸ªä¸»é¢˜ç»§ç»­åœ¨ Hugo å¼•æ“ä¸­ä¹Ÿèƒ½å¾—åˆ°å‘æ‰¬å…‰å¤§ï¼Œåœ¨æ­¤ä¹Ÿæ¬¢è¿ä½ çš„åŠ å…¥ï¼
æˆ‘ä»¬çš„æ„¿æ™¯ å»¶ç»­ NexT ç»å…¸çš„é»‘ç™½è°ƒæ­é…ï¼Œä¿æŒç®€å•çš„æ˜“ç”¨æ€§åŠå¼ºå¤§çš„åŠŸèƒ½ã€‚
ä½¿ç”¨åé¦ˆ åŠ å…¥ GitHub Discussions æˆ– Gitter åœ¨çº¿è®¨è®º ğŸ» GitHub Issues æäº¤é”™è¯¯æŠ¥å‘Š ğŸ› GitHub Feature è¡¨æ–°åŠŸèƒ½çš„æƒ³æ³• âœ¨ åŒæ—¶å›½å†…ç”¨æˆ·ä¹Ÿå¯åŠ å…¥ QQ ç¾¤äº¤æµï¼š 604710815</content></entry><entry><title>ç«™ç‚¹ç¤ºä¾‹</title><url>/flinks.html</url><categories/><tags/><content type="html"> å¦‚æƒ³äº¤æ¢æœ¬ç«™å‹æƒ…é“¾æ¥ï¼Œè¯·åœ¨è¯„è®ºåŒºç•™ä¸‹ä½ çš„ç«™ç‚¹ä¿¡æ¯ï¼Œæ ¼å¼å‚è€ƒå¦‚ä¸‹ï¼š
- name: Hugo-NexT desc: Hugo NexT å®˜æ–¹é¢„è§ˆç½‘ç«™ã€‚ avatar: https://hugo-next.eu.org/imgs/hugo_next_avatar.png link: https://hugo-next.eu.org</content></entry></search>