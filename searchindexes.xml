<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>200. å²›å±¿æ•°é‡</title><url>/leetcode/leetcode_number-of-islands/</url><categories><category>leetcode</category></categories><tags><tag>æœç´¢</tag></tags><content type="html"><![CDATA[   https://leetcode.cn/problems/number-of-islands/ ç»™ä½ ä¸€ä¸ªç”± &lsquo;1&rsquo;ï¼ˆé™†åœ°ï¼‰å’Œ &lsquo;0&rsquo;ï¼ˆæ°´ï¼‰ç»„æˆçš„çš„äºŒç»´ç½‘æ ¼ï¼Œè¯·ä½ è®¡ç®—ç½‘æ ¼ä¸­å²›å±¿çš„æ•°é‡ã€‚
å²›å±¿æ€»æ˜¯è¢«æ°´åŒ…å›´ï¼Œå¹¶ä¸”æ¯åº§å²›å±¿åªèƒ½ç”±æ°´å¹³æ–¹å‘å’Œ/æˆ–ç«–ç›´æ–¹å‘ä¸Šç›¸é‚»çš„é™†åœ°è¿æ¥å½¢æˆã€‚
æ­¤å¤–ï¼Œä½ å¯ä»¥å‡è®¾è¯¥ç½‘æ ¼çš„å››æ¡è¾¹å‡è¢«æ°´åŒ…å›´ã€‚
ç¤ºä¾‹ 1ï¼š
è¾“å…¥ï¼š
grid = [ [&#34;1&#34;,&#34;1&#34;,&#34;1&#34;,&#34;1&#34;,&#34;0&#34;], [&#34;1&#34;,&#34;1&#34;,&#34;0&#34;,&#34;1&#34;,&#34;0&#34;], [&#34;1&#34;,&#34;1&#34;,&#34;0&#34;,&#34;0&#34;,&#34;0&#34;], [&#34;0&#34;,&#34;0&#34;,&#34;0&#34;,&#34;0&#34;,&#34;0&#34;] ] è¾“å‡ºï¼š1
ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼š
grid = [ [&#34;1&#34;,&#34;1&#34;,&#34;0&#34;,&#34;0&#34;,&#34;0&#34;], [&#34;1&#34;,&#34;1&#34;,&#34;0&#34;,&#34;0&#34;,&#34;0&#34;], [&#34;0&#34;,&#34;0&#34;,&#34;1&#34;,&#34;0&#34;,&#34;0&#34;], [&#34;0&#34;,&#34;0&#34;,&#34;0&#34;,&#34;1&#34;,&#34;1&#34;] ] è¾“å‡ºï¼š3
æç¤ºï¼š
m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 300 grid[i][j] çš„å€¼ä¸º &lsquo;0&rsquo; æˆ– &lsquo;1&rsquo; ä»£ç  const ( valid byte = &#39;1&#39; inValid byte = &#39;0&#39; ) func numIslands(grid [][]byte) int { copyGrid := make([][]byte, 0) copyGrid = append(copyGrid, grid...) var count int for i := 0; i &lt; len(copyGrid); i++ { for j := 0; j &lt; len(copyGrid[i]); j++ { if copyGrid[i][j] == valid { mark(copyGrid, i, j) count++ } } } return count } func mark(copyGrid [][]byte, i, j int) { if i &lt; 0 || i &gt;= len(copyGrid) || j &lt; 0 || j &gt;= len(copyGrid[i]) { return } if copyGrid[i][j] == inValid { return } copyGrid[i][j] = inValid mark(copyGrid, i, j+1) mark(copyGrid, i, j-1) mark(copyGrid, i+1, j) mark(copyGrid, i-1, j) }   ]]></content></entry><entry><title>33. æœç´¢æ—‹è½¬æ’åºæ•°ç»„</title><url>/leetcode/leetcode_search-in-rotated-sorted-array/</url><categories><category>leetcode</category></categories><tags><tag>åŒæŒ‡é’ˆ</tag><tag>äºŒåˆ†æŸ¥æ‰¾</tag></tags><content type="html"><![CDATA[   https://leetcode.cn/problems/search-in-rotated-sorted-array/ æ•´æ•°æ•°ç»„ nums æŒ‰å‡åºæ’åˆ—ï¼Œæ•°ç»„ä¸­çš„å€¼ äº’ä¸ç›¸åŒ ã€‚
åœ¨ä¼ é€’ç»™å‡½æ•°ä¹‹å‰ï¼Œnums åœ¨é¢„å…ˆæœªçŸ¥çš„æŸä¸ªä¸‹æ ‡ kï¼ˆ0 &lt;= k &lt; nums.lengthï¼‰ä¸Šè¿›è¡Œäº† æ—‹è½¬ï¼Œä½¿æ•°ç»„å˜ä¸º [nums[k], nums[k+1], &hellip;, nums[n-1], nums[0], nums[1], &hellip;, nums[k-1]]ï¼ˆä¸‹æ ‡ ä» 0 å¼€å§‹ è®¡æ•°ï¼‰ã€‚ä¾‹å¦‚ï¼Œ [0,1,2,4,5,6,7] åœ¨ä¸‹æ ‡ 3 å¤„ç»æ—‹è½¬åå¯èƒ½å˜ä¸º [4,5,6,7,0,1,2] ã€‚
ç»™ä½  æ—‹è½¬å çš„æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•° target ï¼Œå¦‚æœ nums ä¸­å­˜åœ¨è¿™ä¸ªç›®æ ‡å€¼ target ï¼Œåˆ™è¿”å›å®ƒçš„ä¸‹æ ‡ï¼Œå¦åˆ™è¿”å› -1 ã€‚
ä½ å¿…é¡»è®¾è®¡ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦ä¸º O(log n) çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜ã€‚
ç¤ºä¾‹ 1ï¼š
è¾“å…¥ï¼šnums = [4,5,6,7,0,1,2], target = 0 è¾“å‡ºï¼š4 ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼šnums = [4,5,6,7,0,1,2], target = 3 è¾“å‡ºï¼š-1 ç¤ºä¾‹ 3ï¼š
è¾“å…¥ï¼šnums = [1], target = 0 è¾“å‡ºï¼š-1 æç¤ºï¼š
1 &lt;= nums.length &lt;= 5000 -104 &lt;= nums[i] &lt;= 104 nums ä¸­çš„æ¯ä¸ªå€¼éƒ½ ç‹¬ä¸€æ— äºŒ é¢˜ç›®æ•°æ®ä¿è¯ nums åœ¨é¢„å…ˆæœªçŸ¥çš„æŸä¸ªä¸‹æ ‡ä¸Šè¿›è¡Œäº†æ—‹è½¬ ä»£ç  func search(nums []int, target int) int { left, right := 0, len(nums)-1 for left &lt;= right { mid := (left + right) / 2 if nums[mid] == target { return mid } if nums[mid] &gt;= nums[left] { if target &gt;= nums[left] &amp;&amp; target &lt; nums[mid] { right = mid-1 } else { left = mid+1 } } else { if target &gt; nums[mid] &amp;&amp; target &lt;= nums[right] { left = mid+1 } else { right = mid - 1 } } } return -1 }   ]]></content></entry><entry><title>1. ä¸¤æ•°ä¹‹å’Œ</title><url>/leetcode/leetcode_two-sum/</url><categories><category>leetcode</category></categories><tags/><content type="html"><![CDATA[   https://leetcode.cn/problems/two-sum/ ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å€¼ targetï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡º å’Œä¸ºç›®æ ‡å€¼ target çš„é‚£ ä¸¤ä¸ª æ•´æ•°ï¼Œå¹¶è¿”å›å®ƒä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚
ä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆã€‚ä½†æ˜¯ï¼Œæ•°ç»„ä¸­åŒä¸€ä¸ªå…ƒç´ åœ¨ç­”æ¡ˆé‡Œä¸èƒ½é‡å¤å‡ºç°ã€‚
ä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆã€‚
ç¤ºä¾‹ 1ï¼š
è¾“å…¥ï¼šnums = [2,7,11,15], target = 9 è¾“å‡ºï¼š[0,1] è§£é‡Šï¼šå› ä¸º nums[0] + nums[1] == 9 ï¼Œè¿”å› [0, 1] ã€‚ ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼šnums = [3,2,4], target = 6 è¾“å‡ºï¼š[1,2] ç¤ºä¾‹ 3ï¼š
è¾“å…¥ï¼šnums = [3,3], target = 6 è¾“å‡ºï¼š[0,1] æç¤ºï¼š
2 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109 -109 &lt;= target &lt;= 109 åªä¼šå­˜åœ¨ä¸€ä¸ªæœ‰æ•ˆç­”æ¡ˆ è¿›é˜¶ï¼šä½ å¯ä»¥æƒ³å‡ºä¸€ä¸ªæ—¶é—´å¤æ‚åº¦å°äº O(n2) çš„ç®—æ³•å—ï¼Ÿ
ä»£ç  func twoSum(nums []int, target int) []int { m := make(map[int]int) for idx, v := range nums { if preIdx, ok := m[v]; ok { return []int{preIdx, idx} } m[target-v] = idx } return nil }   ]]></content></entry><entry><title>102. äºŒå‰æ ‘çš„å±‚åºéå†</title><url>/leetcode/leetcode_binary-tree-level-order-traversal/</url><categories><category>leetcode</category></categories><tags><tag>äºŒå‰æ ‘</tag></tags><content type="html"><![CDATA[   https://leetcode.cn/problems/binary-tree-level-order-traversal/ ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ å±‚åºéå† ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚
ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7] è¾“å‡ºï¼š[[3],[9,20],[15,7]] ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼šroot = [1] è¾“å‡ºï¼š[[1]] ç¤ºä¾‹ 3ï¼š
è¾“å…¥ï¼šroot = [] è¾“å‡ºï¼š[] æç¤ºï¼š
æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ [0, 2000] å†… -1000 &lt;= Node.val &lt;= 1000 ä»£ç  type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func levelOrder(root *TreeNode) [][]int { var res [][]int if root == nil { return res } var queue []*TreeNode queue = append(queue, root) var idx int for len(queue) &gt; 0 { res = append(res, []int{}) var layer []*TreeNode for j := 0; j &lt; len(queue); j++ { node := queue[j] res[idx] = append(res[idx], node.Val) if node.Left != nil { layer = append(layer, node.Left) } if node.Right != nil { layer = append(layer, node.Right) } } queue = layer idx++ } return res }   ]]></content></entry><entry><title>21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨</title><url>/leetcode/leetcode_merge-two-sorted-lists/</url><categories><category>leetcode</category></categories><tags><tag>é“¾è¡¨</tag></tags><content type="html"><![CDATA[   https://leetcode.cn/problems/merge-two-sorted-lists/ å°†ä¸¤ä¸ªå‡åºé“¾è¡¨åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„ å‡åº é“¾è¡¨å¹¶è¿”å›ã€‚æ–°é“¾è¡¨æ˜¯é€šè¿‡æ‹¼æ¥ç»™å®šçš„ä¸¤ä¸ªé“¾è¡¨çš„æ‰€æœ‰èŠ‚ç‚¹ç»„æˆçš„ã€‚
ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šl1 = [1,2,4], l2 = [1,3,4] è¾“å‡ºï¼š[1,1,2,3,4,4] ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼šl1 = [], l2 = [] è¾“å‡ºï¼š[] ç¤ºä¾‹ 3ï¼š
è¾“å…¥ï¼šl1 = [], l2 = [0] è¾“å‡ºï¼š[0] ä»£ç  func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode { if list1 == nil { return list2 } if list2 == nil { return list1 } n1, n2 := list1, list2 target := &amp;ListNode{} h := target for n1 != nil || n2 != nil { // n1, n2 å…¶ä¸­ä¸€ä¸ªé“¾è¡¨ç”¨å®Œåï¼Œå¦ä¸€ä¸ªé“¾è¡¨ç›´æ¥åŠ å…¥ç»“æœ if n1 == nil { target.Next = n2 break } if n2 == nil { target.Next = n1 break } // n1,n2 æ¯”è¾ƒï¼ŒæŠŠå°çš„åŠ å…¥ç»“æœï¼Œå¹¶ç§»åŠ¨é“¾è¡¨ if n1.Val &lt;= n2.Val { target.Next = &amp;ListNode{ Val: n1.Val, } n1 = n1.Next target = target.Next } else { target.Next = &amp;ListNode{ Val: n2.Val, } n2 = n2.Next target = target.Next } } return h.Next }   ]]></content></entry><entry><title>409. æœ€é•¿å›æ–‡ä¸²</title><url>/leetcode/leetcode_longest-palindrome/</url><categories><category>leetcode</category></categories><tags><tag>åŒæŒ‡é’ˆ</tag></tags><content type="html"><![CDATA[   https://leetcode.cn/problems/longest-palindrome/ ç»™å®šä¸€ä¸ªåŒ…å«å¤§å†™å­—æ¯å’Œå°å†™å­—æ¯çš„å­—ç¬¦ä¸² s ï¼Œè¿”å› é€šè¿‡è¿™äº›å­—æ¯æ„é€ æˆçš„ æœ€é•¿çš„å›æ–‡ä¸² ã€‚
åœ¨æ„é€ è¿‡ç¨‹ä¸­ï¼Œè¯·æ³¨æ„ åŒºåˆ†å¤§å°å†™ ã€‚æ¯”å¦‚ &ldquo;Aa&rdquo; ä¸èƒ½å½“åšä¸€ä¸ªå›æ–‡å­—ç¬¦ä¸²ã€‚
ç¤ºä¾‹ 1:
è¾“å…¥:s = &#34;abccccdd&#34; è¾“å‡º:7 è§£é‡Š: æˆ‘ä»¬å¯ä»¥æ„é€ çš„æœ€é•¿çš„å›æ–‡ä¸²æ˜¯&#34;dccaccd&#34;, å®ƒçš„é•¿åº¦æ˜¯ 7ã€‚ ç¤ºä¾‹ 2:
è¾“å…¥:s = &#34;a&#34; è¾“å‡º:1 ç¤ºä¾‹ 3ï¼š
è¾“å…¥:s = &#34;aaaaaccc&#34; è¾“å‡º:7 æç¤º:
1 &lt;= s.length &lt;= 2000 s åªç”±å°å†™ å’Œ/æˆ– å¤§å†™è‹±æ–‡å­—æ¯ç»„æˆ
è§£é¢˜æ€è·¯ åŒæ•°å³å¯å‚ä¸æ„æˆå›æ–‡æ•°ï¼Œå› æ­¤ç»™å„ä¸ªæˆå‘˜è®¡æ•°ï¼Œå¦‚æœæ˜¯å•æ•°ï¼Œå–len-1ï¼ŒåŒæ•°ï¼Œå–lenã€‚ æœ€ä¸­é—´çš„æ•°å¯ä»¥æ˜¯å•ä¸ªï¼Œå› æ­¤ï¼Œå¦‚æœæœ€ç»ˆç»“æœå°äºlen(s)ï¼Œè¯´æ˜æœ‰å…ƒç´ ä¸ºå•æ•°ï¼Œå¯ä»¥+1æŠŠå¤šå‡ºæ¥çš„æ”¾ä¸­é—´ã€‚ ä»£ç  func longestPalindrome(s string) int { m := make(map[rune]int) for _, c := range s { m[c] += 1 } var sum int for _, v := range m { sum += v / 2 * 2 } if sum &lt; len(s) { sum++ } return sum }   ]]></content></entry><entry><title>912. æ’åºæ•°ç»„</title><url>/leetcode/leetcode_sort-an-array/</url><categories><category>leetcode</category></categories><tags><tag>å¿«æ’</tag></tags><content type="html"><![CDATA[   https://leetcode.cn/problems/sort-an-array/ ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ numsï¼Œè¯·ä½ å°†è¯¥æ•°ç»„å‡åºæ’åˆ—ã€‚
ç¤ºä¾‹ 1ï¼š
è¾“å…¥ï¼šnums = [5,2,3,1] è¾“å‡ºï¼š[1,2,3,5] ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼šnums = [5,1,1,2,0,0] è¾“å‡ºï¼š[0,0,1,1,2,5] æç¤ºï¼š
1 &lt;= nums.length &lt;= 5 * 104 -5 * 104 &lt;= nums[i] &lt;= 5 * 104
è§£é¢˜æ€è·¯ æ’åºé¢˜ï¼Œå¿«æ’ ä»£ç  // å¿«é€Ÿæ’åº func quickSort(nums []int) { // é€’å½’ç»ˆæ­¢æ¡ä»¶ if len(nums) &lt; 2 { return } // éšæœºé€‰æ‹©åŸºå‡†å€¼ pivotIndex := rand.Intn(len(nums)) pivot := nums[pivotIndex] // åˆ†åŒº left, right := 0, len(nums)-1 for left &lt;= right { for nums[left] &lt; pivot { left++ } for nums[right] &gt; pivot { right-- } if left &lt;= right { nums[left], nums[right] = nums[right], nums[left] left++ right-- } } // é€’å½’ quickSort(nums[:right+1]) quickSort(nums[left:]) return } å¿«æ’å¤ªå¸¸è§äº†ï¼Œä½†æ˜¯å¥½ä¹…æ²¡ç¢°ï¼Œæˆ‘å®é™…ç ä»£ç çš„æ—¶å€™é‡åˆ°äº†ä¸å°‘é—®é¢˜ï¼Œæ­£å¥½æ•´ç†ä¸€ä¸‹ã€‚
å¿«æ’çš„æ ¸å¿ƒæ€æƒ³å°±æ˜¯æŠŠæ— åºçš„åºåˆ—æ ¹æ®ä¸€ä¸ªåŸºå‡†å€¼åˆ†æˆ2ä»½æ— åºçš„åºåˆ—ï¼Œå®è§‚ä¸Šï¼Œä¸¤ä»½åºåˆ—æœ‰åºã€‚å†å¯¹è¿™ä¸¤ä»½æ— åºçš„åºåˆ—åšåŒæ ·çš„å¤„ç†ã€‚ æœ‰ä¸€äº›è¾¹ç•Œæƒ…å†µéœ€è¦è€ƒè™‘ï¼š æœ‰ç›¸åŒå€¼ï¼Œè¿™ä¸ªæ—¶å€™ï¼Œä¸ºäº†ç¡®ä¿ç›¸åŒå€¼ä¹‹é—´çš„å€¼èƒ½å‚ä¸æ’åºï¼Œéœ€è¦è·³è¿‡ç›¸åŒçš„å€¼æˆ–è€…äº¤æ¢ç›¸åŒçš„å€¼ï¼› ä¸ºäº†é˜²æ­¢æ­»å¾ªç¯ï¼Œåœ¨åˆ†æˆ2ä»½åºåˆ—çš„æ—¶å€™ï¼Œä¸èƒ½å‡ºç°æŸä¸ªåºåˆ—ä¸ºç©ºçš„æƒ…å†µã€‚å¦‚ [1,6]ï¼Œ6ä¸ºåŸºå‡†å€¼ï¼Œä»–å¯èƒ½ä¼šåˆ†æˆ [1,6] å’Œ []ï¼Œç„¶åé™·å…¥æ­»å¾ªç¯ï¼› left å’Œ right æ¯ä¸€è½®äº¤æ¢åï¼Œå¯èƒ½ä¼šæœ‰3ç§æƒ…å†µ åŸºå‡†å€¼å’Œå¦ä¸€ä¸ªå¯ä»¥äº¤æ¢çš„å€¼ã€‚è¿™ç§æƒ…å†µï¼ŒåŸºå‡†å€¼ä¼šå˜åŒ–ä½ç½®ã€‚è¿™ä¸ªæ—¶å€™ï¼Œleft å’Œ right éƒ½å¯èƒ½æŒ‡å‘åŸºå‡†å€¼ã€‚ right æŒ‡å‘åŸºå‡†å€¼å·¦è¾¹çš„ä¸€ä¸ªå€¼ï¼Œleft æŒ‡å‘åŸºå‡†å€¼ right æŒ‡å‘åŸºå‡†å€¼ï¼Œleft æŒ‡å‘åŸºå‡†å€¼å³è¾¹çš„ä¸€ä¸ªå€¼ åªæœ‰ä¸€ä¸ªåŸºå‡†å€¼ã€‚è¿™ä¸ªæ—¶å€™ left å’Œ right åœ¨åŸºå‡†å€¼ä¸¤ä¾§ æ²¡æœ‰åŸºå‡†å€¼ã€‚åŸºå‡†å€¼æå‰è¢«äº¤æ¢æ‰äº†ï¼Œright æŒ‡å‘ä¸€ä¸ªæ¯”åŸºå‡†å€¼å°çš„å€¼ï¼Œleft æŒ‡å‘ä¸€ä¸ªæ¯”åŸºå‡†å€¼å¤§çš„å€¼ï¼Œä¸”ç›¸é‚» æ¯è½®äº¤æ¢åï¼Œleft å’Œ right ç»ˆæ€ä¸€å®šæ˜¯ left åœ¨ right å³è¾¹ æ ¹æ®2ã€3å’Œ4ï¼Œä¸‹ä¸€è½®çš„åˆ†ç»„åº”è¯¥å– [0:right] å’Œ [left:len-1]   ]]></content></entry><entry><title>53. æœ€å¤§å­æ•°ç»„å’Œ</title><url>/leetcode/leetcode_maximum-subarray/</url><categories><category>leetcode</category></categories><tags><tag>æ¡¶æ’åº</tag></tags><content type="html"><![CDATA[   https://leetcode.cn/problems/maximum-subarray/ ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œè¯·ä½ æ‰¾å‡ºä¸€ä¸ªå…·æœ‰æœ€å¤§å’Œçš„è¿ç»­å­æ•°ç»„ï¼ˆå­æ•°ç»„æœ€å°‘åŒ…å«ä¸€ä¸ªå…ƒç´ ï¼‰ï¼Œè¿”å›å…¶æœ€å¤§å’Œã€‚
å­æ•°ç»„ æ˜¯æ•°ç»„ä¸­çš„ä¸€ä¸ªè¿ç»­éƒ¨åˆ†ã€‚
ç¤ºä¾‹ 1ï¼š
è¾“å…¥ï¼šnums = [-2,1,-3,4,-1,2,1,-5,4] è¾“å‡ºï¼š6 è§£é‡Šï¼šè¿ç»­å­æ•°ç»„ [4,-1,2,1] çš„å’Œæœ€å¤§ï¼Œä¸º 6 ã€‚ ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼šnums = [1] è¾“å‡ºï¼š1 ç¤ºä¾‹ 3ï¼š
è¾“å…¥ï¼šnums = [5,4,-1,7,8] è¾“å‡ºï¼š23 æç¤ºï¼š
1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104
è¿›é˜¶ï¼šå¦‚æœä½ å·²ç»å®ç°å¤æ‚åº¦ä¸º O(n) çš„è§£æ³•ï¼Œå°è¯•ä½¿ç”¨æ›´ä¸ºç²¾å¦™çš„ åˆ†æ²»æ³• æ±‚è§£ã€‚
è§£é¢˜æ€è·¯ éå†ï¼Œå‰nä¸ªæ•°ç›¸åŠ ï¼Œå¦‚æœå°äºç¬¬nä¸ªæ•°ï¼Œåˆ™èˆå»å‰n-1ä¸ªæ•°ï¼Œè¿™æ ·å¯ä»¥ä¿è¯ å‰nä¸ªæ•°æœ€å¤§ ä»£ç  func maxSubArray(nums []int) int { if len(nums) == 0 { return 0 } max := nums[0] sum := nums[0] nums = nums[1:] for _, v := range nums { if sum+v &gt; v { sum += v } else { sum = v } if max &lt; sum { max = sum } } return max }   ]]></content></entry><entry><title>15. ä¸‰æ•°ä¹‹å’Œ</title><url>/leetcode/leetcode_3sum/</url><categories><category>leetcode</category></categories><tags><tag>åŒæŒ‡é’ˆ</tag></tags><content type="html"><![CDATA[   https://leetcode.cn/problems/3sum/ ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œåˆ¤æ–­æ˜¯å¦å­˜åœ¨ä¸‰å…ƒç»„ [nums[i], nums[j], nums[k]] æ»¡è¶³ i != jã€i != k ä¸” j != k ï¼ŒåŒæ—¶è¿˜æ»¡è¶³ nums[i] + nums[j] + nums[k] == 0 ã€‚è¯·
ä½ è¿”å›æ‰€æœ‰å’Œä¸º 0 ä¸”ä¸é‡å¤çš„ä¸‰å…ƒç»„ã€‚
æ³¨æ„ï¼šç­”æ¡ˆä¸­ä¸å¯ä»¥åŒ…å«é‡å¤çš„ä¸‰å…ƒç»„ã€‚
ç¤ºä¾‹ 1ï¼š
è¾“å…¥ï¼šnums = [-1,0,1,2,-1,-4] è¾“å‡ºï¼š[[-1,-1,2],[-1,0,1]] è§£é‡Šï¼š nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 ã€‚ nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 ã€‚ nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 ã€‚ ä¸åŒçš„ä¸‰å…ƒç»„æ˜¯ [-1,0,1] å’Œ [-1,-1,2] ã€‚ æ³¨æ„ï¼Œè¾“å‡ºçš„é¡ºåºå’Œä¸‰å…ƒç»„çš„é¡ºåºå¹¶ä¸é‡è¦ã€‚ ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼šnums = [0,1,1] è¾“å‡ºï¼š[] è§£é‡Šï¼šå”¯ä¸€å¯èƒ½çš„ä¸‰å…ƒç»„å’Œä¸ä¸º 0 ã€‚ ç¤ºä¾‹ 3ï¼š
è¾“å…¥ï¼šnums = [0,0,0] è¾“å‡ºï¼š[[0,0,0]] è§£é‡Šï¼šå”¯ä¸€å¯èƒ½çš„ä¸‰å…ƒç»„å’Œä¸º 0 ã€‚ æç¤ºï¼š
3 &lt;= nums.length &lt;= 3000 -105 &lt;= nums[i] &lt;= 105
è§£é¢˜æ€è·¯ éå†ï¼Œä¸¤ä¸¤æ±‚å’Œï¼Œå¾—åˆ°ä¸€ä¸ªæ–°çš„æ•°ç»„ï¼Œç„¶åå†éå†åŸæ•°ç»„ï¼Œæ±‚å¾—å’Œä¸º0çš„æˆå‘˜ã€‚è¿™æ ·åšå¤æ‚åº¦æ¯”è¾ƒé«˜ï¼Œæœ‰O(n^2)ï¼Œè€Œä¸”éœ€è¦è®°ä¸‹æ ‡ï¼Œæ„Ÿè§‰ä¸å¤ªå¥½ã€‚ å…ˆæ’åºï¼Œç„¶åéå†ç¬¬ä¸€ä¸ªå€¼ï¼Œç¬¬äºŒä¸ªå’Œç¬¬ä¸‰ä¸ªå€¼ä½¿ç”¨åŒæŒ‡é’ˆã€‚æ³¨æ„å»é‡ã€‚ ä»£ç  func threeSum(nums []int) [][]int { // ç‰¹æ®Šcaseåˆ¤æ–­ if len(nums) &lt; 3 { return nil } // æ’åº sort.Ints(nums) var res [][]int h := 0 for h &lt; len(nums) &amp;&amp; nums[h] &lt;= 0 { // è·³è¿‡é‡å¤ if h &gt; 0 &amp;&amp; nums[h] == nums[h-1] { h++ continue } l := h + 1 r := len(nums) - 1 // åŒæŒ‡é’ˆ for l &lt; r { if nums[h]+nums[l]+nums[r] == 0 { res = append(res, []int{nums[h], nums[l], nums[r]}) // å»é‡ for l &lt; r &amp;&amp; nums[l] == nums[l+1] { l++ } for l &lt; r &amp;&amp; nums[r] == nums[r-1] { r-- } l++ r-- } else if nums[h]+nums[l]+nums[r] &lt; 0 { l++ } else { r-- } } h++ } return res }   ]]></content></entry><entry><title>25. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨</title><url>/leetcode/leetcode_reverse-nodes-in-k-group/</url><categories><category>leetcode</category></categories><tags><tag>é“¾è¡¨</tag><tag>æ»‘åŠ¨çª—å£</tag></tags><content type="html"><![CDATA[   https://leetcode.cn/problems/reverse-nodes-in-k-group/ ç»™ä½ é“¾è¡¨çš„å¤´èŠ‚ç‚¹ head ï¼Œæ¯ k ä¸ªèŠ‚ç‚¹ä¸€ç»„è¿›è¡Œç¿»è½¬ï¼Œè¯·ä½ è¿”å›ä¿®æ”¹åçš„é“¾è¡¨ã€‚
k æ˜¯ä¸€ä¸ªæ­£æ•´æ•°ï¼Œå®ƒçš„å€¼å°äºæˆ–ç­‰äºé“¾è¡¨çš„é•¿åº¦ã€‚å¦‚æœèŠ‚ç‚¹æ€»æ•°ä¸æ˜¯ k çš„æ•´æ•°å€ï¼Œé‚£ä¹ˆè¯·å°†æœ€åå‰©ä½™çš„èŠ‚ç‚¹ä¿æŒåŸæœ‰é¡ºåºã€‚
ä½ ä¸èƒ½åªæ˜¯å•çº¯çš„æ”¹å˜èŠ‚ç‚¹å†…éƒ¨çš„å€¼ï¼Œè€Œæ˜¯éœ€è¦å®é™…è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢ã€‚
ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šhead = [1,2,3,4,5], k = 2 è¾“å‡ºï¼š[2,1,4,3,5] ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šhead = [1,2,3,4,5], k = 3 è¾“å‡ºï¼š[3,2,1,4,5] æç¤ºï¼š é“¾è¡¨ä¸­çš„èŠ‚ç‚¹æ•°ç›®ä¸º n
1 &lt;= k &lt;= n &lt;= 5000
0 &lt;= Node.val &lt;= 1000
è¿›é˜¶ï¼šä½ å¯ä»¥è®¾è®¡ä¸€ä¸ªåªç”¨ O(1) é¢å¤–å†…å­˜ç©ºé—´çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜å—ï¼Ÿ
è§£é¢˜æ€è·¯ éå†é“¾è¡¨ï¼ŒæŠŠå®ƒåˆ†æˆ len / k + 1 æ®µï¼Œå¯¹æ¯æ®µè¿›è¡Œç¿»è½¬å¤„ç†ï¼Œæœ€ååˆå¹¶
ä»£ç  type ListNode struct { Val int Next *ListNode } func reverseKGroup(head *ListNode, k int) *ListNode { var counter int h := head var list []*ListNode // éå†ï¼Œæ¯kä¸ªåˆ†ä¸€ç»„ for head != nil { counter++ if counter == k { a := head head = head.Next a.Next = nil list = append(list, reverse(h)) h = head counter = 0 } else { head = head.Next } } // ä¸æ»¡k if counter != 0 { list = append(list, h) } // é˜²æ­¢ä¸‹æ ‡è¶Šç•Œ if len(list) == 0 { return nil } // è®°å½•å¤´èŠ‚ç‚¹ head = list[0] // åˆå¹¶å„ä¸ªåˆ†ç»„ for i := range list { if i == len(list)-1 { break } for list[i].Next != nil { list[i] = list[i].Next } list[i].Next = list[i+1] } return head } func reverse(head *ListNode) *ListNode { var prev *ListNode curr := head for curr != nil { next := curr.Next curr.Next = prev prev = curr curr = next } return prev } ä¸ä¸ºå‡ må†…å­˜è€ŒæŠ˜è…°ï¼Œä¸‹ä¸€é¢˜ï¼
  ]]></content></entry><entry><title>215. æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ </title><url>/leetcode/leetcode_kth-largest-element-in-an-array/</url><categories><category>leetcode</category></categories><tags><tag>æ¡¶æ’åº</tag></tags><content type="html"><![CDATA[   https://leetcode.cn/problems/kth-largest-element-in-an-array/ ç»™å®šæ•´æ•°æ•°ç»„ nums å’Œæ•´æ•° kï¼Œè¯·è¿”å›æ•°ç»„ä¸­ç¬¬ k ä¸ªæœ€å¤§çš„å…ƒç´ ã€‚
è¯·æ³¨æ„ï¼Œä½ éœ€è¦æ‰¾çš„æ˜¯æ•°ç»„æ’åºåçš„ç¬¬ k ä¸ªæœ€å¤§çš„å…ƒç´ ï¼Œè€Œä¸æ˜¯ç¬¬ k ä¸ªä¸åŒçš„å…ƒç´ ã€‚
ä½ å¿…é¡»è®¾è®¡å¹¶å®ç°æ—¶é—´å¤æ‚åº¦ä¸º O(n) çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜ã€‚
ç¤ºä¾‹ 1:
è¾“å…¥: [3,2,1,5,6,4], k = 2 è¾“å‡º: 5 ç¤ºä¾‹ 2: è¾“å…¥: [3,2,3,1,2,4,5,5,6], k = 4 è¾“å‡º: 4 æç¤ºï¼š
1 &lt;= k &lt;= nums.length &lt;= 10^5
-10^4 &lt;= nums[i] &lt;= 10^4
è§£é¢˜æ€è·¯ å…ˆè€ƒè™‘ä¸€ä¸‹éšè—æ¡ä»¶ï¼š å…ƒç´ å¯èƒ½ä¼šé‡å¤ é¦–å…ˆæƒ³åˆ°çš„ï¼Œå› ä¸º nums æ˜¯æ— åºçš„ï¼Œå› æ­¤è‡³å°‘éœ€è¦éå†ä¸€éï¼Œé¢˜ç›®è¦æ±‚ O(n) ï¼Œåˆ™è¡¨ç¤ºéœ€è¦åœ¨éå†çš„è¿‡ç¨‹ä¸­æ’å¥½åºã€‚è‡ªç„¶å°±æƒ³åˆ°äº†æ¡¶æ’åºã€‚ ä»£ç  func findKthLargest(nums []int, k int) int { bucket := make([]int, 20001) for _, v := range nums { bucket[v+10000]++ } count := len(bucket) - 1 for { if bucket[count] &gt; 0 { k = k - bucket[count] } if k &lt;= 0 { return count - 10000 } count-- } } åè®° çœ‹ä¸€çœ¼ç­”æ¡ˆï¼Œå±…ç„¶æ˜¯å¿«æ’ T_T ã€‚ä¸ªäººå…¶å®ä¸å–œæ¬¢ç”¨æ¡¶æ’åºï¼Œå› ä¸ºå—ä¸‹æ ‡çº¦æŸï¼Œä¸å¤Ÿæ³›ç”¨ï¼Œå¹¶ä¸”å®ƒçš„æ€æƒ³å¾ˆåˆ«æ‰­ï¼Œæ„Ÿè§‰å°±åƒä½¿ç”¨redisçš„æ—¶å€™kvåç€å­˜ã€‚
ä½†æ˜¯æ—¢ç„¶å·²ç»å†™äº†ï¼Œå¹¶ä¸”æ¼‚äº®åœ°é€šè¿‡äº†ï¼Œé‚£ä¹ˆå¿«æ’å…„ï¼Œä¸‹æ¬¡ä¸€å®šï¼æºœ~
  ]]></content></entry><entry><title>go ç»“æ„ä½“åŒ…å«æ¥å£æˆå‘˜è¿›è¡Œååºåˆ—åŒ–</title><url>/practical/go_struct_contains_interface/</url><categories><category>å®æˆ˜é—®é¢˜</category></categories><tags><tag>golang</tag><tag>json</tag></tags><content type="html"><![CDATA[   å·¥ä½œä¸­é‡åˆ°ä¸€ä¸ªé—®é¢˜ï¼Œç»“æ„ä½“åŒ…å«æ¥å£ç±»å‹çš„æˆå‘˜æ—¶ï¼Œåœ¨ååºåˆ—åŒ–çš„æ—¶å€™ä¼šæŠ¥é”™ã€‚
// Task æ¥å£ç±»å‹ type Task interface { Exec() error } // TaskA Taskæ¥å£çš„å®ç°ç±»A type TaskA struct { A string `json:&#34;a&#34;` } func (ta *TaskA) Exec() error { fmt.Println(&#34;TaskA Exec&#34;) return nil } // TaskB Taskæ¥å£çš„å®ç°ç±»B type TaskB struct { B string `json:&#34;b&#34;` } func (tb *TaskB) Exec() error { fmt.Println(&#34;TaskB Exec&#34;) return nil } // MixedStruct ååºåˆ—åŒ–ç›®æ ‡ç»“æ„ä½“ type MixedStruct struct { Id uint64 `json:&#34;id&#34;` Task Task `json:&#34;task&#34;` } åœºæ™¯ è¿™ä¸ªç»“æ„ä½“åœ¨ååºåˆ—åŒ–çš„è¿‡ç¨‹ä¸­ä¼šæŠ¥é”™ã€‚
éœ€è¦ç»™æ¥å£èµ‹å€¼å…·ä½“çš„ç»“æ„ä½“æ‰èƒ½æ­£å¸¸ååºåˆ—åŒ–ã€‚
func TestUnmarshal(t *testing.T) { t.Run(&#34;å¸¦ Interface çš„ç»“æ„ä½“ååºåˆ—åŒ–&#34;, func(t *testing.T) { str := &#34;{\&#34;id\&#34;:1,\&#34;task\&#34;:{\&#34;a\&#34;:\&#34;a\&#34;}}&#34; var mixed MixedStruct err := jsoniter.UnmarshalFromString(str, &amp;mixed) assert.NotNil(t, err) t.Log(err) // json_jsoniter.MixedStruct.Task: decode non empty interface: can not unmarshal into nil, error found in #10 byte of ...|:1,&#34;task&#34;:{&#34;a&#34;:&#34;a&#34;}}|..., bigger context ...|{&#34;id&#34;:1,&#34;task&#34;:{&#34;a&#34;:&#34;a&#34;}}|... mixed.Task = &amp;TaskA{} err = jsoniter.UnmarshalFromString(str, &amp;mixed) assert.Nil(t, err) }) } è§£å†³æ–¹æ¡ˆ æ–¹æ¡ˆä¸€ ç›´æ¥å¹²æ‰é—®é¢˜ï¼Œä¸å­˜æ¥å£ï¼Œå­˜JSONå­—ç¬¦ä¸²ã€‚
ä¼˜ç‚¹ï¼šç®€å•ç²—æš´
ç¼ºç‚¹ï¼šå¿…é¡»åœ¨ä¸šåŠ¡ä¸­è§£æè¿™ä¸ªå­—æ®µï¼ŒåŠ å¤§äº†å¤æ‚åº¦ï¼Œå¢åŠ äº†é‡å¤å·¥ä½œã€‚
æ–¹æ¡ˆäºŒ åœ¨ä¸šåŠ¡ä¸­ç»™æ¥å£æˆå‘˜èµ‹å€¼ã€‚
å¦‚ï¼š
mixed.Task = &amp;TaskA{} _ = jsoniter.UnmarshalFromString(str, &amp;mixed) ä¼˜ç‚¹ï¼šç®€å•ç²—æš´
ç¼ºç‚¹ï¼šèµ‹å€¼æˆä¸ºå‰ç½®æ¡ä»¶ï¼Œä¸åŒäºæ­£å¸¸çš„ååºåˆ—åŒ–æ“ä½œï¼Œåœ¨å®é™…å·¥ç¨‹ä¸­å®¹æ˜“é—å¿˜ã€‚ä¸”åœ¨ååŒå¼€å‘æ—¶å¿…é¡»å’Œæ‰€æœ‰å¼€å‘æˆå‘˜åŒæ­¥ã€‚
æ–¹æ¡ˆä¸‰ å¢åŠ ä¸€ä¸ª taskType ç±»å‹ï¼Œæ¥è¡¨ç¤ºå®ç°å“ªä¸ªç»“æ„ä½“
å®ç° UnmarshalJSON å‡½æ•°
const ( TaskTypeA = 1 TaskTypeB = 2 ) type MixedStruct struct { Id uint64 `json:&#34;id&#34;` TaskType int `json:&#34;taskType&#34;` Task Task `json:&#34;task&#34;` } func (a *MixedStruct) UnmarshalJSON(b []byte) error { if a.Task == nil { // ç»™æ¥å£èµ‹å€¼å…·ä½“å®ç°ç±» taskType := jsoniter.Get(b, &#34;taskType&#34;) switch taskType.ToInt() { case TaskTypeA: a.Task = &amp;TaskA{} case TaskTypeB: a.Task = &amp;TaskB{} default: return errors.New(&#34;illegal task type&#34;) } } // ç»“æ„éœ€è¦è·ŸMixedStruct ä¿æŒä¸€è‡´ tmp := struct { Id uint64 `json:&#34;id&#34;` TaskType int `json:&#34;taskType&#34;` Task Task `json:&#34;task&#34;` }{} tmp.Task = a.Task if err := jsoniter.Unmarshal(b, &amp;tmp); err != nil { return err } a.Id = tmp.Id a.Task = tmp.Task a.TaskType = tmp.TaskType return nil } ä¼˜ç‚¹ï¼šå®Œç¾è§£å†³é—®é¢˜ï¼Œååºåˆ—åŒ–çš„æ—¶å€™ä¸éœ€è¦é¢å¤–æ“ä½œ
ç¼ºç‚¹ï¼šæœ‰ç»´æŠ¤æˆæœ¬ï¼Œéœ€è¦ç»´æŠ¤taskTypeçš„æšä¸¾å€¼ï¼Œä¸”åœ¨ç»™MixedStruct å¢åŠ å­—æ®µçš„æ—¶å€™å¿…é¡»å¯¹åº”ç»´æŠ¤UnmarshalJSONçš„å®ç°ã€‚
ä¸»è¦æ˜¯æƒ³ä»‹ç»è¿™ä¸ªæ–¹æ¡ˆä¸‰ï¼Œå¯¹äºå®ƒçš„ç¼ºç‚¹ï¼š
taskType è¿™ä¸ªå€¼åŸºæœ¬ä¸Šä¸è®ºæ˜¯å¦ç”¨æ¥å£æˆå‘˜ï¼Œéƒ½éœ€è¦ç»´æŠ¤ï¼Œæ²¡æœ‰å¢åŠ å®é™…æˆæœ¬ã€‚ å¯ä»¥æŠŠ MixedStruct å’Œ UnmarshalJSON æ”¾åœ¨ä¸€ä¸ªæ–‡ä»¶é‡Œï¼Œå¹¶åœ¨æ¥å£æˆå‘˜çš„åé¢åŠ ä¸Šå¯¹åº”æ³¨é‡Šï¼Œèµ·åˆ°å¤‡å¿˜å’Œæç¤ºçš„ä½œç”¨ã€‚ è¿˜æœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„ï¼Œåœ¨èµ‹å€¼ Task çš„æ—¶å€™ï¼Œä¸è¦ç”¨ä½¿ç”¨ç±»ä¼¼äº a.Task = b.Task ï¼Œå› ä¸º Task æ˜¯åœ°å€ç±»å‹ï¼Œä½¿ç”¨çš„æ˜¯åŒä¸€ç‰‡å†…å­˜ï¼Œä¿®æ”¹ a.Task çš„æ—¶å€™ï¼Œb.Task ä¹Ÿä¼šå—å½±å“ï¼Œå»ºè®®ç»™Task å¢åŠ ä¸€ä¸ª Copy() æ–¹æ³•ï¼Œå®ç°æ·±æ‹·è´ã€‚
  ]]></content></entry><entry><title>146. LRU ç¼“å­˜</title><url>/leetcode/leetcode_lru-cache/</url><categories><category>leetcode</category></categories><tags><tag>é“¾è¡¨</tag><tag>ç¼“å­˜</tag></tags><content type="html"><![CDATA[   https://leetcode.cn/problems/lru-cache è¯·ä½ è®¾è®¡å¹¶å®ç°ä¸€ä¸ªæ»¡è¶³ LRU (æœ€è¿‘æœ€å°‘ä½¿ç”¨) ç¼“å­˜ çº¦æŸçš„æ•°æ®ç»“æ„ã€‚
å®ç° LRUCache ç±»ï¼š
LRUCache(int capacity) ä»¥ æ­£æ•´æ•° ä½œä¸ºå®¹é‡ capacity åˆå§‹åŒ– LRU ç¼“å­˜ int get(int key) å¦‚æœå…³é”®å­— key å­˜åœ¨äºç¼“å­˜ä¸­ï¼Œåˆ™è¿”å›å…³é”®å­—çš„å€¼ï¼Œå¦åˆ™è¿”å› -1 ã€‚ void put(int key, int value) å¦‚æœå…³é”®å­— key å·²ç»å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶æ•°æ®å€¼ value ï¼›å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™å‘ç¼“å­˜ä¸­æ’å…¥è¯¥ç»„ key-value ã€‚å¦‚æœæ’å…¥æ“ä½œå¯¼è‡´å…³é”®å­—æ•°é‡è¶…è¿‡ capacity ï¼Œåˆ™åº”è¯¥ é€å‡º æœ€ä¹…æœªä½¿ç”¨çš„å…³é”®å­—ã€‚ å‡½æ•° get å’Œ put å¿…é¡»ä»¥ O(1) çš„å¹³å‡æ—¶é—´å¤æ‚åº¦è¿è¡Œã€‚ ç¤ºä¾‹ï¼š
è¾“å…¥ [&#34;LRUCache&#34;, &#34;put&#34;, &#34;put&#34;, &#34;get&#34;, &#34;put&#34;, &#34;get&#34;, &#34;put&#34;, &#34;get&#34;, &#34;get&#34;, &#34;get&#34;] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] è¾“å‡º [null, null, null, 1, null, -1, null, -1, 3, 4] è§£é‡Š LRUCache lRUCache = new LRUCache(2); lRUCache.put(1, 1); // ç¼“å­˜æ˜¯ {1=1} lRUCache.put(2, 2); // ç¼“å­˜æ˜¯ {1=1, 2=2} lRUCache.get(1); // è¿”å› 1 lRUCache.put(3, 3); // è¯¥æ“ä½œä¼šä½¿å¾—å…³é”®å­— 2 ä½œåºŸï¼Œç¼“å­˜æ˜¯ {1=1, 3=3} lRUCache.get(2); // è¿”å› -1 (æœªæ‰¾åˆ°) lRUCache.put(4, 4); // è¯¥æ“ä½œä¼šä½¿å¾—å…³é”®å­— 1 ä½œåºŸï¼Œç¼“å­˜æ˜¯ {4=4, 3=3} lRUCache.get(1); // è¿”å› -1 (æœªæ‰¾åˆ°) lRUCache.get(3); // è¿”å› 3 lRUCache.get(4); // è¿”å› 4 æç¤ºï¼š
1 &lt;= capacity &lt;= 3000 0 &lt;= key &lt;= 10000 0 &lt;= value &lt;= 105 æœ€å¤šè°ƒç”¨ 2 * 105 æ¬¡ get å’Œ put
è§£é¢˜æ€è·¯ å®ç°åŠŸèƒ½ ä¸»è¦åŠŸèƒ½æ˜¯ Get å’Œ Putï¼Œå…ˆåˆ†æä¸€ä¸‹è¿™ä¸¤ä¸ªæ–¹æ³•éœ€è¦å®ç°ä»€ä¹ˆåŠŸèƒ½
Get
è·å–ç¼“å­˜å€¼ æé«˜keyçš„ä¼˜å…ˆçº§ Put
key å·²å­˜åœ¨ è®¾ç½®ç¼“å­˜ è®¾ç½®å½“å‰key çš„ä¼˜å…ˆçº§ä¸ºæœ€é«˜ key ä¸å­˜åœ¨ è®¾ç½®ç¼“å­˜ è®¾ç½®å½“å‰key çš„ä¼˜å…ˆçº§ä¸ºæœ€é«˜ æ£€æŸ¥ç¼“å­˜å®¹é‡ æ•°æ®ç»“æ„ é¦–å…ˆæ˜¯ç¼“å­˜å†…å®¹ï¼Œä¾¿äºå­˜å–ï¼Œä½¿ç”¨map æœ€åˆé€‚
å…¶æ¬¡æ˜¯ä¼˜å…ˆçº§ï¼Œä»–éœ€è¦éœ€è¦æ”¯æŒ
å°†æŸä¸ªkeyçš„ä¼˜å…ˆçº§æåˆ°æœ€é«˜ åˆ é™¤ä¼˜å…ˆçº§æœ€ä½çš„key è¿™é‡Œå°±è€ƒè™‘åˆ°äº† åˆ‡ç‰‡ã€é“¾è¡¨
åˆ‡ç‰‡ï¼šåˆ é™¤key æ¯”è¾ƒæ–¹ä¾¿ã€‚ä½†æ˜¯å®šä½keyæ¥æå‡ä¼˜å…ˆçº§éœ€è¦ O(n) çš„å¤æ‚åº¦ é“¾è¡¨ï¼šåˆ é™¤key éœ€è¦çŸ¥é“è¡¨å°¾ï¼Œç”¨åŒå‘é“¾è¡¨ã€‚æå‡ä¼˜å…ˆçº§å°†å¯¹åº”çš„èŠ‚ç‚¹æåˆ°è¡¨å¤´å³å¯ã€‚åŒå‘é“¾è¡¨å®Œæˆè¿™ä¸¤ä¸ªèƒ½åŠ›çš„æˆæœ¬æ›´ä½ã€‚ ä»£ç  type Node struct { key, val int pre, next *Node } type LRUCache struct { m map[int]*Node // ç¼“å­˜æ˜ å°„ head, tail *Node // åŒå‘é“¾è¡¨ï¼Œç»´æŠ¤ä¼˜å…ˆçº§ï¼Œhead æŒ‡å‘ä¼˜å…ˆçº§æœ€é«˜ cap int // æœ€å¤§å®¹é‡ size int // å½“å‰ç¼“å­˜æ•°é‡ } func Constructor(capacity int) LRUCache { l := LRUCache{ m: make(map[int]*Node, capacity), head: &amp;Node{}, tail: &amp;Node{}, cap: capacity, } l.head.next = l.tail l.tail.pre = l.head return l } /* * Get è·å–ç¼“å­˜ 1. è·å–ç¼“å­˜å€¼ 2. æé«˜å½“å‰key çš„ä¼˜å…ˆçº§ */ func (this *LRUCache) Get(key int) int { node, ok := this.m[key] if ok { this.moveToHead(node) return node.val } return -1 } /* * Put è®¾ç½®ç¼“å­˜ ä¸¤ç§æƒ…å†µï¼š case1ï¼škey å·²å­˜åœ¨ 1. è®¾ç½®ç¼“å­˜ 2. æé«˜å½“å‰key çš„ä¼˜å…ˆçº§ case2: key ä¸å­˜åœ¨ 1. è®¾ç½®ç¼“å­˜ 2. åœ¨è¡¨å¤´æ’å…¥key 3. æ£€æŸ¥ç¼“å­˜å®¹é‡ */ func (this *LRUCache) Put(key int, value int) { node, ok := this.m[key] if ok { node.val = value this.moveToHead(node) } else { node = &amp;Node{ key: key, val: value, } this.m[key] = node this.addToHead(node) this.size++ } for this.size &gt; this.cap { tail := this.removeTail() delete(this.m, tail.key) this.size-- } } func (this *LRUCache) addToHead(node *Node) { node.pre = this.head node.next = this.head.next this.head.next.pre = node this.head.next = node } func (this *LRUCache) removeNode(node *Node) { node.pre.next = node.next node.next.pre = node.pre } func (this *LRUCache) moveToHead(node *Node) { this.removeNode(node) this.addToHead(node) } func (this *LRUCache) removeTail() *Node { node := this.tail.pre this.removeNode(node) return node }   ]]></content></entry><entry><title>206. åè½¬é“¾è¡¨</title><url>/leetcode/leetcode_reverse-linked-list/</url><categories><category>leetcode</category></categories><tags><tag>é“¾è¡¨</tag><tag>æ»‘åŠ¨çª—å£</tag></tags><content type="html"> https://leetcode.cn/problems/reverse-linked-list ç»™ä½ å•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ head ï¼Œè¯·ä½ åè½¬é“¾è¡¨ï¼Œå¹¶è¿”å›åè½¬åçš„é“¾è¡¨ã€‚
ç¤ºä¾‹ 1ï¼š
è¾“å…¥ï¼šhead = [1,2,3,4,5] è¾“å‡ºï¼š[5,4,3,2,1] ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼šhead = [1,2] è¾“å‡ºï¼š[2,1] ç¤ºä¾‹ 3ï¼š
è¾“å…¥ï¼šhead = [] è¾“å‡ºï¼š[] æç¤ºï¼š
é“¾è¡¨ä¸­èŠ‚ç‚¹çš„æ•°ç›®èŒƒå›´æ˜¯ [0, 5000] -5000 &amp;lt;= Node.val &amp;lt;= 5000
è¿›é˜¶ï¼šé“¾è¡¨å¯ä»¥é€‰ç”¨è¿­ä»£æˆ–é€’å½’æ–¹å¼å®Œæˆåè½¬ã€‚ä½ èƒ½å¦ç”¨ä¸¤ç§æ–¹æ³•è§£å†³è¿™é“é¢˜ï¼Ÿ
è§£é¢˜æ€è·¯ æ–¹æ¡ˆä¸€
éå†å…¥å †æ ˆï¼Œå†è¯»ä¸€é æ–¹æ¡ˆäºŒ
ç›´æ¥è°ƒè½¬æŒ‡å‘ï¼Œç”¨ä¸´æ—¶èŠ‚ç‚¹è®°å½•ä¸­é—´å€¼ æ–¹æ¡ˆä¸‰
é€’å½’å›æº¯ è¿™ä¸ªæ–¹æ¡ˆæ²¡æƒ³åˆ°ï¼Œåˆ©ç”¨é€’å½’ä»é“¾è¡¨å°¾å›æº¯åˆ°é“¾è¡¨å¤´ï¼Œå®Œæˆç¿»è½¬ æœ¬ç€åšé¢˜çš„ç›®çš„ï¼Œæˆ‘çš„codingæ˜¯æ–¹æ¡ˆäºŒã€‚å…¶å®å®é™…å¼€å‘ä¸­é‡åˆ°ç±»ä¼¼çš„é—®é¢˜ï¼Œæ€§èƒ½å†…å­˜ä¸æ˜¯ç“¶é¢ˆçš„æƒ…å†µä¸‹ï¼Œæˆ‘ä¼šæ¯«ä¸çŠ¹è±«åœ°é€‰æ‹©æ–¹æ¡ˆä¸€ã€‚å¯è¯»æ€§é«˜ï¼Œè€Œä¸”ä¸å®¹æ˜“å‡ºé”™ã€‚
ä»£ç  func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } var target, mid1, mid2 *ListNode mid1, mid2 = head, head.Next for mid2 != nil { mid2 = mid1.Next mid1.Next = target target = mid1 mid1 = mid2 } return target }</content></entry><entry><title>3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²</title><url>/leetcode/leetcode_longest-substring-without-repeating-characters/</url><categories><category>leetcode</category></categories><tags><tag>é˜Ÿåˆ—</tag><tag>æ»‘åŠ¨çª—å£</tag></tags><content type="html"><![CDATA[   https://leetcode.cn/problems/longest-substring-without-repeating-characters/ ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² s ï¼Œè¯·ä½ æ‰¾å‡ºå…¶ä¸­ä¸å«æœ‰é‡å¤å­—ç¬¦çš„ æœ€é•¿å­ä¸² çš„é•¿åº¦ã€‚
ç¤ºä¾‹ 1:
è¾“å…¥: s = &#34;abcabcbb&#34; è¾“å‡º: 3 è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ &#34;abc&#34;ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 3ã€‚ ç¤ºä¾‹ 2:
è¾“å…¥: s = &#34;bbbbb&#34; è¾“å‡º: 1 è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ &#34;b&#34;ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 1ã€‚ ç¤ºä¾‹ 3:
è¾“å…¥: s = &#34;pwwkew&#34; è¾“å‡º: 3 è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ &#34;wke&#34;ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 3ã€‚ è¯·æ³¨æ„ï¼Œä½ çš„ç­”æ¡ˆå¿…é¡»æ˜¯ å­ä¸² çš„é•¿åº¦ï¼Œ&#34;pwke&#34; æ˜¯ä¸€ä¸ªå­åºåˆ—ï¼Œä¸æ˜¯å­ä¸²ã€‚ æç¤ºï¼š
0 &lt;= s.length &lt;= 5 * 104 s ç”±è‹±æ–‡å­—æ¯ã€æ•°å­—ã€ç¬¦å·å’Œç©ºæ ¼ç»„æˆ è§£é¢˜æ€è·¯ æœ¬é¢˜æ±‚çš„æ˜¯å­åºåˆ—ï¼Œæ˜¯è¿ç»­çš„ï¼Œå› æ­¤å¯ä»¥åˆ©ç”¨æ»‘åŠ¨çª—å£çš„æ€æƒ³å’Œé˜Ÿåˆ—çš„æ•°æ®ç»“æ„ã€‚ å­åºåˆ—éœ€è¦æ»¡è¶³ä¸é‡å¤çš„è§„åˆ™ï¼Œå¯ä»¥éå†å­—ç¬¦ä¸²ï¼Œé‡åˆ°é‡å¤çš„å­—ç¬¦ä¸¢å¼ƒå‰ä¸€ä¸ªè¯¥å­—ç¬¦åŠå…¶ä»¥å‰çš„éƒ¨åˆ†ï¼Œæ¯æ¬¡æ»‘åŠ¨éƒ½è®°å½•é•¿åº¦ã€‚ ä»£ç  func lengthOfLongestSubstring(s string) int { var max int m := make(map[rune]struct{}) var queue []rune for _, v := range s { if _, ok := m[v]; ok { for len(queue) &gt; 0 &amp;&amp; queue[0] != v { delete(m, queue[0]) queue = queue[1:] } delete(m, queue[0]) queue = queue[1:] } m[v] = struct{}{} queue = append(queue, v) if len(queue) &gt; max { max = len(queue) } } return max }   ]]></content></entry><entry><title>MySQL where èŒƒå›´æŸ¥è¯¢å’Œ order by å…³é”®å­—æ— æ³•åŒæ—¶å‘½ä¸­ç´¢å¼•</title><url>/practical/index_in_orderby/</url><categories><category>å®æˆ˜é—®é¢˜</category></categories><tags><tag>MySQL</tag><tag>ç´¢å¼•</tag></tags><content type="html"><![CDATA[   å¼€å‘ä¸­ï¼Œä½¿ç”¨ in å’Œ order by çš„æ—¶å€™ï¼Œå‘ç°æ— æ³•åŒæ—¶å‘½ä¸­ç´¢å¼•ã€‚
ä½¿ç”¨ IN è¿ç®—ç¬¦æ¥è¿‡æ»¤è¡Œæ—¶ï¼ŒMySQL ä¼šå…ˆä½¿ç”¨ç´¢å¼•æ¥å®šä½è¡¨ä¸­çš„è¡Œï¼Œå¹¶å°†è¿™äº›è¡Œçš„æ‰€æœ‰æ•°æ®è¯»å…¥å†…å­˜ä¸­ã€‚éšåï¼ŒMySQL ä¼šæ ¹æ®æŸ¥è¯¢è¯­å¥ä¸­çš„ ORDER BY å­å¥å¯¹è¿™äº›æ•°æ®è¿›è¡Œæ’åºã€‚
ç®€å•åœºæ™¯æ„é€  CREATE TABLE `c` ( `id` bigint unsigned NOT NULL AUTO_INCREMENT, `a` int NOT NULL DEFAULT &#39;0&#39;, `b` int NOT NULL DEFAULT &#39;0&#39;, `c` int NOT NULL DEFAULT &#39;0&#39;, PRIMARY KEY (`id`), KEY `abc` (`a`,`b`,`c`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci -- data insert into c(a, b, c) values (1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 2, 1), (1, 2, 2), (1, 2, 3), (1, 2, 3), (2, 2, 2), (3, 3, 3); Explain SELECT éèŒƒå›´æŸ¥è¯¢ explain select * from c where a = 1 and b = 1 order by c; /* +----+-------------+-------+------------+------+---------------+------+---------+-------------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+-------------+------+----------+-------------+ | 1 | SIMPLE | c | NULL | ref | abc | abc | 8 | const,const | 3 | 100.00 | Using index | +----+-------------+-------+------------+------+---------------+------+---------+-------------+------+----------+-------------+ */ èƒ½å¤Ÿå®Œç¾å‘½ä¸­ç´¢å¼•ã€‚
èŒƒå›´æŸ¥è¯¢ explain select * from c where a = 1 and b &gt; 1 order by c; /* +----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+------------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+------------------------------------------+ | 1 | SIMPLE | c | NULL | range | abc | abc | 8 | NULL | 4 | 100.00 | Using where; Using index; Using filesort | +----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+------------------------------------------+ */ èŒƒå›´æŸ¥è¯¢ç”¨åˆ°äº†filesortï¼Œè¡¨ç¤º order byæ²¡æœ‰å‘½ä¸­ç´¢å¼•ï¼Œabc ç´¢å¼•çš„ä½œç”¨ç›¸å½“äº abã€‚
ç´¢å¼•åˆ†æ ç´¢å¼•ç»“æ„
a b c 1 1 1 2 3 2 1 2 3 3 2 2 2 3 3 3 select * from c where a = 1 and b = 1 order by c; åœ¨éèŒƒå›´æŸ¥è¯¢çš„æ—¶å€™ï¼Œå¯ä»¥å‘ç°ï¼Œç»è¿‡whereè¯­å¥ï¼Œcçš„èŒƒå›´æ˜¯ 1ã€2ã€3ï¼Œbå·²ç¡®å®šï¼Œc æœ‰åºï¼Œorder by å¯ä»¥å‘½ä¸­ç´¢å¼•ã€‚
select * from c where a = 1 and b &gt; 1 order by c; åœ¨èŒƒå›´æŸ¥è¯¢çš„æ—¶å€™ï¼Œç»è¿‡whereè¯­å¥ï¼Œcçš„èŒƒå›´æ˜¯ 1ã€2ã€3ã€1ã€2ã€3ã€3ï¼Œbæ— æ³•ç¡®å®šï¼ˆå¯èƒ½ä¸º1æˆ–2ï¼‰ï¼Œc ä¸ºæ— åºï¼Œorder by æ— æ³•å‘½ä¸­ç´¢å¼•ã€‚
  ]]></content></entry><entry><title>Gorm çš„é»‘é­”æ³•</title><url>/practical/gorm_black_magic/</url><categories><category>å®æˆ˜é—®é¢˜</category></categories><tags><tag>golang</tag><tag>gorm</tag></tags><content type="html"><![CDATA[   å°ä¼™çœ‹åˆ°åŒäº‹å†™çš„Gormé»‘é­”æ³•ï¼Œé€æ¸ä¸æ·¡å®šäº†ã€‚
å¼€å‘è¿‡ç¨‹ä¸­ï¼Œçœ‹åˆ°åŒäº‹çš„ä»£ç å†™äº†è¿™ä¹ˆä¸€æ®µï¼š
db = db.Session(&amp;amp;gorm.Session{Context: db.Statement.Context}).FirstOrCreate(&amp;amp;entity) if db.Error !=nil{ return components.ErrorDbInsert.WrapPrintf(db.Error, &amp;#34;Insert error, entity:%s&amp;#34;, utils.ToJson(entity)) } if db.RowsAffected == 0 { return components.ErrorAlreadyExist } FirstOrCreate æˆ‘ä¸ç¦æ„Ÿåˆ°ç–‘æƒ‘ï¼Œgorm çš„ RowsAffected åœ¨è¿›è¡ŒæŸ¥è¯¢ï¼Œå¦‚æœæŸ¥åˆ°æ•°æ®ï¼Œä¹Ÿæ˜¯æœ‰å€¼çš„ï¼Œä¸ºä»€ä¹ˆåœ¨è¿™é‡Œå¯ä»¥ç”¨ RowsAffected == 0 æ¥åˆ¤æ–­æ•°æ®å·²å­˜åœ¨ï¼Ÿ
æŠ±ç€è¿™ä¸ªç–‘é—®ï¼Œæˆ‘ç‚¹å¼€äº† FirstOrCreate çš„ä»£ç ï¼š
func (db *DB) FirstOrCreate(dest interface{}, conds ...interface{}) (tx *DB) { queryTx := db.Limit(1).Order(clause.OrderByColumn{ Column: clause.Column{Table: clause.CurrentTable, Name: clause.PrimaryKey}, }) if tx = queryTx.Find(dest, conds...); queryTx.RowsAffected == 0 { ... return tx.Create(dest) } else if len(db.Statement.assigns) &amp;gt; 0 { ... return tx.Model(dest).Updates(assigns) } return db } æˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“åœ°å‘ç°ï¼Œåœ¨ Find æŸ¥åˆ°æ•°æ®ä¸” assigns æ²¡æœ‰å€¼çš„æƒ…å†µä¸‹ï¼Œreturn çš„æ˜¯ dbï¼Œè€Œå…¶ä»–æƒ…å†µä¸‹ return çš„æ˜¯ txã€‚ç›´è§‰å‘Šè¯‰æˆ‘ï¼ŒåŸå› å¤§æ¦‚ç‡åœ¨è¿™ä¸ªä¸Šé¢ã€‚
getInstance() Limitã€Orderã€Findç­‰è®¸å¤šå‡½æ•°éƒ½è°ƒç”¨äº†åŒä¸€ â€¦  ]]></content></entry><entry><title>MySQL ç´¢å¼•æ’åº</title><url>/learning/mysql_index_sort/</url><categories><category>æŠ€æœ¯å­¦ä¹ </category></categories><tags><tag>MySQL</tag><tag>ç´¢å¼•</tag></tags><content type="html"> å¼€å‘è¿‡ç¨‹ä¸­å‘ç°SQLä¸€ç›´filesortï¼Œæ‰€ä»¥ç ”ç©¶ä¸€ä¸‹åˆ°ä½æ€ä¹ˆæ‰èƒ½ä½¿ç”¨ç´¢å¼•è¿›è¡Œæ’åºã€‚
è¡¨ç»“æ„å’Œæ•°æ® CREATE TABLE `t1` ( `id` int(11) NOT NULL AUTO_INCREMENT, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, `c` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `idx_a_b_c` (`a`,`b`,`c`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; id a b c 1 1 5 3 2 5 3 3 3 4 5 9 4 2 6 1 5 4 3 2 6 5 5 5 7 1 2 1 8 5 5 8 9 5 3 9 10 5 5 1 11 5 7 7 SQL explain select * from t where a = 5 order by c desc; -- type:ref -- key:idx_a_b_c -- ref:const -- Extra:Using where; Using index; Using filesort explain select * from t where a = 5 order by b desc; -- type:ref -- key:idx_a_b_c -- ref:const -- Extra:Using where; Using index explain select * from t where a = 5 and c = 5 order by b desc; -- type:ref -- key:idx_a_b_c -- ref:const -- Extra:Using where; Using index explain select * from t where a = 5 and b = 5 order by c desc; -- type:ref -- key:idx_a_b_c -- ref:const,const -- Extra:Using where; Using index explain select * from t where a = 5 and b &amp;gt;= 5 order by c desc; -- type:range -- key:idx_a_b_c -- ref:NULL -- Extra:Using where; Using index; Using filesort ç´¢å¼•åˆ†æ é€šè¿‡è§‚å¯Ÿè”åˆç´¢å¼•çš„æ•°æ®ç»“æ„ï¼Œå¾ˆæ˜æ˜¾å°±èƒ½å‘ç°ç´¢å¼•éƒ½æ˜¯æœ‰åºçš„ï¼Œä½¿ç”¨ç´¢å¼•è¿›è¡Œæ’åºå°±æ˜¯åˆ©ç”¨äº†è¿™ä¸ªç‰¹æ€§ã€‚
æˆ‘ä»¬æ¥è§‚å¯Ÿ a = 5 çš„è¿™ä¸€æ®µç´¢å¼•ï¼Œå¾ˆå®¹æ˜“å°±èƒ½å‘ç°ï¼Œåœ¨ a ç¡®å®šçš„æƒ…å†µä¸‹ï¼Œb æ˜¯æœ‰åºçš„ï¼Œä½†c æ˜¯æ— åºçš„ã€‚a å’Œ b å‘½ä¸­ç´¢å¼•ï¼Œa å’Œ c ä¸å‘½ä¸­ç´¢å¼•
åœ¨ a,b éƒ½ç¡®å®šçš„æƒ…å†µä¸‹ï¼Œc æ˜¯æœ‰åºçš„ã€‚a,b,c å‘½ä¸­ç´¢å¼•
è¿™å°±æ˜¯è€ç”Ÿå¸¸è°ˆçš„ æœ€ä½³å·¦å‰ç¼€åŸåˆ™ ä¹Ÿå« æœ€å·¦å‰ç¼€åŒ¹é…åŸåˆ™
å› æ­¤ï¼Œè¦è®©æ’åºé¡¹ä½¿ç”¨ç´¢å¼•è¿›è¡Œæ’åº
ç¬¬ä¸€ä¸ªæ¡ä»¶å°±æ˜¯ï¼šwhereæ¡ä»¶+æ’åºé¡¹ç¬¦åˆæœ€ä½³å·¦å‰ç¼€åŸåˆ™
ç¬¬äºŒä¸ªæ¡ä»¶ï¼šä¸èƒ½ä½¿ç”¨æ¡ä»¶æŸ¥è¯¢
è¿™ä¸ªä¹Ÿå¯ä»¥é€šè¿‡è§‚å¯Ÿè”åˆç´¢å¼•å¾—å‡ºç»“è®º
a = 5 AND b &amp;gt;= 5 æ˜¾ç„¶æ˜¯æ— æ³•ä¿è¯ c æ˜¯æœ‰åºçš„
ç»“è®º è¦è®©order by ä½¿ç”¨ç´¢å¼•æ’åºï¼Œéœ€è¦è‡³å°‘æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š
whereæ¡ä»¶+æ’åºé¡¹ç¬¦åˆæœ€ä½³å·¦å‰ç¼€åŸåˆ™ ä¸èƒ½ä½¿ç”¨æ¡ä»¶æŸ¥è¯¢</content></entry><entry><title>go çš„åˆ‡ç‰‡æ‰©å®¹</title><url>/learning/slice_expand/</url><categories><category>æŠ€æœ¯å­¦ä¹ </category></categories><tags><tag>golang</tag></tags><content type="html"><![CDATA[   åœ¨uber çš„goè¯­è¨€ç¼–ç è§„èŒƒä¸­æœ‰è¿™ä¹ˆä¸€æ¡ï¼Œ2.48s å’Œ0.21s çš„å·®è·è¿˜æ˜¯å¾ˆæƒŠäººäº†ï¼Œæˆ‘å¾ˆå¥½å¥‡ï¼Œwhyï¼Ÿ
åˆ‡ç‰‡åœ¨appendçš„æ—¶å€™å¯èƒ½ä¼šè‡ªåŠ¨æ‰©å®¹ï¼Œçœ‹ä¸€ä¸‹ç›¸å…³æºç ã€‚
slice type slice struct { array unsafe.Pointer len int cap int } func makeslice(et *_type, len, cap int) unsafe.Pointer { // 1. è®¡ç®—éœ€è¦ç”³è¯·çš„å®¹é‡ï¼Œå¹¶åˆ¤æ–­æ˜¯å¦å†…å­˜æº¢å‡º mem, overflow := math.MulUintptr(et.size, uintptr(cap)) // 2. å†…å­˜æº¢å‡ºåŸå›  if overflow || mem &gt; maxAlloc || len &lt; 0 || len &gt; cap { // è®¡ç®—sliceæ‰€éœ€å†…å­˜é€šè¿‡MulUintptræ¥å®ç°çš„ mem, overflow := math.MulUintptr(et.size, uintptr(len)) if overflow || mem &gt; maxAlloc || len &lt; 0 { panicmakeslicelen() } panicmakeslicecap() } // 3. è¿›è¡Œå†…å­˜åˆ†é… return mallocgc(mem, et, true) } func growslice(et *_type, old slice, cap int) slice { ... newcap := old.cap doublecap := newcap + newcap if cap &gt; doublecap { newcap = cap } else { // å½“åŸåˆ‡ç‰‡é•¿åº¦å°äº1024æ—¶ï¼Œæ–°åˆ‡ç‰‡çš„å®¹é‡ä¼šç›´æ¥ç¿»å€ã€‚è€Œå½“åŸåˆ‡ç‰‡çš„å®¹é‡å¤§äºç­‰äº1024æ—¶ï¼Œä¼šåå¤åœ°å¢åŠ 25%ï¼Œç›´åˆ°æ–°å®¹é‡è¶…è¿‡æ‰€éœ€è¦çš„å®¹é‡ if old.cap &lt; 1024 { newcap = doublecap } else { for 0 &lt; newcap &amp;&amp; newcap &lt; cap { newcap += newcap / 4 } if newcap &lt;= 0 { newcap = cap } } } var overflow bool var lenmem, newlenmem, capmem uintptr switch { case et.size == 1: lenmem = uintptr(old.len) newlenmem = uintptr(cap) capmem = roundupsize(uintptr(newcap)) overflow = uintptr(newcap) &gt; maxAlloc newcap = int(capmem) case et.size == sys.PtrSize: lenmem = uintptr(old.len) * sys.PtrSize newlenmem = uintptr(cap) * sys.PtrSize capmem = roundupsize(uintptr(newcap) * sys.PtrSize) overflow = uintptr(newcap) &gt; maxAlloc/sys.PtrSize newcap = int(capmem / sys.PtrSize) case isPowerOfTwo(et.size): var shift uintptr if sys.PtrSize == 8 { // Mask shift for better code generation. shift = uintptr(sys.Ctz64(uint64(et.size))) &amp; 63 } else { shift = uintptr(sys.Ctz32(uint32(et.size))) &amp; 31 } lenmem = uintptr(old.len) &lt;&lt; shift newlenmem = uintptr(cap) &lt;&lt; shift capmem = roundupsize(uintptr(newcap) &lt;&lt; shift) overflow = uintptr(newcap) &gt; (maxAlloc &gt;&gt; shift) newcap = int(capmem &gt;&gt; shift) default: lenmem = uintptr(old.len) * et.size newlenmem = uintptr(cap) * et.size capmem, overflow = math.MulUintptr(et.size, uintptr(newcap)) capmem = roundupsize(capmem) newcap = int(capmem / et.size) } ... } package runtime // å†…å­˜å¯¹é½çš„è¿‡ç¨‹ï¼Œä¸ºäº†é¿å…é€ æˆè¿‡å¤šçš„å†…å­˜ç¢ç‰‡ func roundupsize(size uintptr) uintptr { // size=1600*8=12800&lt;32768 if size &lt; _MaxSmallSize { // 12800&lt;=0 if size &lt;= smallSizeMax-8 { return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]]) } else { return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])//size_to_class128[92]= 56 //class_to_size[56]=13568 //13568/8=1696 } } if size+_PageSize &lt; size { return size } return round(size, _PageSize) } const _MaxSmallSize = 32768 const smallSizeDiv = 8 const smallSizeMax = 1024 const largeSizeDiv = 128 æ€»ç»“ sliceå®¹é‡çš„æ‰©å®¹è§„åˆ™ï¼šå½“åŸsliceçš„capå°äº1024æ—¶ï¼Œæ–°sliceçš„capå˜ä¸ºåŸæ¥çš„2å€ï¼›åŸsliceçš„capå¤§äº1024æ—¶ï¼Œæ–°sliceå˜ä¸ºåŸæ¥çš„1.25å€ï¼ŒæŒ‰ç…§è¿™ä¸ªè§„åˆ™æ‰©å……åï¼Œè¿˜ä¼šè¿›è¡Œå†…å­˜å¯¹é½æ“ä½œã€‚
å›åˆ°å¼€å¤´ï¼Œä¸ºä»€ä¹ˆç¡®å®šåˆ‡ç‰‡å®¹é‡çš„ç¨‹åºæ•ˆç‡æ›´é«˜ï¼Ÿå› ä¸ºä»–çœå»äº†æ‰©å®¹çš„æ­¥éª¤ã€‚
æ‰©å±•ï¼šå†…å­˜å¯¹é½çš„ç›®çš„ å‡è®¾CPUçš„å†…å­˜è¯»å†™å•ä½ä¸º4å­—èŠ‚
åœ¨å†…å­˜å¯¹é½å’Œéå¯¹é½æƒ…å†µä¸‹ï¼Œè¯»å–å˜é‡aéƒ½ä»…éœ€è¦è¯»å–ä¸€æ¬¡ã€‚
åœ¨å†…å­˜å¯¹é½æƒ…å†µä¸‹ï¼Œå¦‚æœè¦è¯»å–å˜é‡bï¼Œåˆ™ä»…éœ€è¦è¯»å–1æ¬¡ï¼Œå³ç¬¬äºŒéƒ¨åˆ†ï¼ˆ4-7ï¼‰ï¼›è€Œéå¯¹é½æƒ…å†µä¸‹ï¼Œåˆ™éœ€è¦è¯»å–2æ¬¡ï¼Œå³ç¬¬ä¸€éƒ¨åˆ†ï¼ˆ0-3ï¼‰å–å3ä¸ªå­—èŠ‚ï¼Œç¬¬äºŒéƒ¨åˆ†å–å‰1ä¸ªå­—èŠ‚ï¼Œç„¶åç”¨æˆ–æ“ä½œæ‹¼æ¥æˆå˜é‡bã€‚
å› æ­¤ï¼Œå†…å­˜å¯¹é½åœ¨æŸäº›æƒ…å†µä¸‹å¯ä»¥å‡å°‘å†…å­˜çš„è¯»å–æ¬¡æ•°ï¼Œæé«˜æ€§èƒ½ï¼Œæ˜¯ä¸€ç§ç©ºé—´æ¢æ—¶é—´çš„ç­–ç•¥ã€‚
  ]]></content></entry><entry><title>go test çš„å†…è”é—®é¢˜</title><url>/practical/inlining/</url><categories><category>å®æˆ˜é—®é¢˜</category></categories><tags><tag>golang</tag><tag>test</tag></tags><content type="html"><![CDATA[   ä½¿ç”¨monkeyå¯¹å‡½æ•°è¿›è¡Œæ‰“æ¡©å•æµ‹çš„æ—¶å€™ï¼Œå‘ç°æ‰“æ¡©å‡½æ•°æ²¡æœ‰ç”Ÿæ•ˆã€‚
ä¹ æƒ¯ç›´æ¥ä½¿ç”¨IDEçš„å¯è§†åŒ–çš„runå’ŒdebugåŠŸèƒ½è¿›è¡Œè·‘å•æµ‹ï¼Œæ²¡æœ‰å…³æ³¨åˆ°å…·ä½“æ‰§è¡Œçš„å‘½ä»¤ã€‚
å•æµ‹ä»£ç  func TestLogin(t *testing.T) { // åˆå§‹åŒ– dao å±‚ userDao := &amp;daoUser.UserDao{} // åˆå§‹åŒ– service å±‚ entity := &amp;LoginService{} Convey(&#34;GetUserByUsername&#34;, t, func() { Convey(&#34;Should be success&#34;, func() { // ç»™ GetByUsername å‡½æ•°æ‰“æ¡©ï¼ŒæŒ‡å®šè¿”å›å€¼ patches := ApplyMethod(reflect.TypeOf(UserDao), &#34;GetByUsername&#34;, func(*daoUser.UserDao, string) (*daoUser.User, error) { return &amp;daoUser.User{ ID: 1, Username: &#34;weirwei&#34;, Password: &#34;123456&#34;, }, nil }) defer patches.Reset() // æµ‹è¯• Login res, err := entity.Login(&#34;weirwei&#34;, &#34;123456&#34;) // æ–­è¨€ So(err, ShouldBeNil) So(res, ShouldBeTrue) }) }) } é—®é¢˜åˆ†æ æŸ¥çœ‹runå’Œdebugçš„å‘½ä»¤
# run /usr/local/go/bin/go test -c -o /private/var/folders/1q/llslx_n95d1brs7hq2drxjjw0000gn/T/___1go_test_gin_study_service_svUser gin-study/service/svUser # debug /usr/local/go/bin/go test -c -o /private/var/folders/1q/llslx_n95d1brs7hq2drxjjw0000gn/T/___go_test_gin_study_service_svUser -gcflags all=-N -l gin-study/service/svUser å¾ˆæ˜æ˜¾å°±èƒ½å‘ç°debugæ¯”runå¤šäº† -gcflags all=-N -lï¼Œè¿™ä¸ªå°±æ˜¯==ç¦ç”¨å†…è”==çš„é€‰é¡¹
å†…è”(inlining)ï¼šç²—æš´çš„æ¥è¯´ï¼Œå°±æ˜¯å°†å‡½æ•°å†…å®¹å¤åˆ¶åˆ°å‡½æ•°è°ƒç”¨çš„åœ°æ–¹ï¼Œ==å‡å°‘äº†å‡½æ•°è°ƒç”¨çš„å¼€æ”¯==ï¼Œä½†ä¸€å®šç¨‹åº¦ä¸Šä¼šå¢åŠ ç¨‹åºçš„ä»£ç é‡ï¼Œ==å ç”¨æ›´å¤šçš„å†…å­˜==ã€‚
è¿™ä¹ˆçœ‹å°±å¾ˆæ˜æ˜¾äº†ï¼Œæœ¬æ¥æ‰“æ¡©å GetUserByUsername ä¼šç›´æ¥è¿”å›ç»™å®šçš„ç»“æœï¼Œä¸èµ° dao å±‚çš„å®é™…ä»£ç ï¼Œä½†æ˜¯ go åœ¨ç¼–è¯‘è¿‡ç¨‹ä¸­ä¼šè¿›è¡Œå†…è”ä¼˜åŒ–ï¼Œå°† dao å±‚çš„ä»£ç ç›´æ¥â€œå¤åˆ¶â€è¿‡æ¥ï¼Œç»•è¿‡äº†æµ‹è¯•æ¡©ã€‚è€Œåœ¨æœ¬æ®µæµ‹è¯•ä»£ç ä¸­å¹¶æ²¡æœ‰å¯¹ dao å±‚è¿›è¡Œç›¸å…³é…ç½®åŠåˆå§‹åŒ–ï¼Œå¯¼è‡´ä»£ç åœ¨æ‰§è¡Œæ—¶å‡ºç°é”™è¯¯ã€‚
  ]]></content></entry><entry><title>Typora + PicGo + Gitee è§£æ”¾ä½ å¯¹å›¾ç‰‡çš„ç®¡ç†</title><url>/tools/typora+picgo+gitee/</url><categories><category>å·¥å…·æ¢ç´¢</category></categories><tags><tag>Markdown</tag><tag>å›¾åºŠ</tag></tags><content type="html"> ä½¿ç”¨markdownåšç¬”è®°çš„æ—¶å€™ï¼Œä½¿ç”¨å›¾ç‰‡æ—¶ï¼Œéœ€è¦å°†å›¾ç‰‡æ”¾åœ¨æŒ‡å®šæ–‡ä»¶å¤¹ï¼Œç„¶åå¼•ç”¨ã€‚è¿™ä¹ˆåšæ¯æ¬¡æ·»åŠ å›¾ç‰‡éƒ½æ¯”è¾ƒå›°éš¾ï¼Œå¹¶ä¸”ä¸ä¾¿äºå¤šç«¯ä½¿ç”¨ã€‚
ä½¿ç”¨PicGoä½œä¸ºå›¾åºŠï¼Œå°†å›¾ç‰‡æ‰˜ç®¡åˆ°Giteeï¼Œåœ¨ä½¿ç”¨Typoraåšç¬”è®°çš„æ—¶å€™å¯ä»¥ç›´æ¥æ— ç¼ä¸Šä¼ å›¾ç‰‡ã€‚
è®¡ç®—æœºç¯å¢ƒå‡†å¤‡ Typora PicGo nodejs Typoraå®˜ç½‘: https://typora.io/ PicGoå®˜ç½‘: https://picgo.github.io/PicGo-Doc/zh/guide/ nodejsä¸‹è½½åœ°å€: http://nodejs.cn/download/ è®¾ç½® Gitee ä½œä¸º PicGo çš„é»˜è®¤å›¾åºŠ åœ¨ PicGo å®‰è£… gitee æ’ä»¶ åœ¨æ’ä»¶è®¾ç½®æœç´¢giteeï¼Œé€‰æ‹©å…¶ä¸­ä¸€ä¸ªå®‰è£…(ä¸¤ä¸ªéƒ½å¯ä»¥ï¼Œåªæ˜¯é…ç½®å†…å®¹æœ‰ç¨è®¸ä¸åŒ)
åœ¨ Gitee åˆ›å»ºå›¾ç‰‡ä»“åº“ æ³¨æ„==ä»“åº“å¿…é¡»å…¬å¼€å¹¶ä¸”ä½¿ç”¨Readmeåˆå§‹åŒ–==
è¿›è¡Œå›¾åºŠé…ç½® è‹¥åœ¨å›¾åºŠè®¾ç½®ä¸­æœªæ‰¾åˆ° Gitee å›¾åºŠï¼Œé‡å¯ PicGo å³å¯
owner: Gitee ç”¨æˆ·å repo: Gitee ä»“åº“å path: Gitee å­˜æ”¾å›¾ç‰‡çš„æ–‡ä»¶å¤¹è·¯å¾„ token: Gitee ç§äººä»¤ç‰Œ message: commit ä¿¡æ¯ ç”Ÿæˆç§äººä»¤ç‰Œ: è®¾ç½®-&amp;gt; ç§äººä»¤ç‰Œ -&amp;gt; ç”Ÿæˆæ–°ä»¤ç‰Œ
åªå‹¾é€‰ projects å³å¯
æäº¤åå¤åˆ¶ token è‡³ PicGo å³å¯
å¯åœ¨ä¸Šä¼ åŒºè¿›è¡Œæµ‹è¯•
é…ç½® Typora ä¸Šä¼ æœåŠ¡ ç„¶åå¼€å§‹æ„‰å¿«åœ° Markdown å§ï¼</content></entry><entry><title>å…³äº Hugo NexT ç»„ç»‡</title><url>/about.html</url><categories/><tags/><content type="html"> Hugo NexT ç»„ç»‡æ˜¯ç”±ä¼—å¤šå–œçˆ± NexT ä¸»é¢˜åŠé£æ ¼çš„ä¸–ç•Œå„åœ°å‹äººå…±åŒç»„å»ºè€Œæˆï¼Œä¸ºçš„å°±æ˜¯è®©è¿™ä¸ªä¸»é¢˜ç»§ç»­åœ¨ Hugo å¼•æ“ä¸­ä¹Ÿèƒ½å¾—åˆ°å‘æ‰¬å…‰å¤§ï¼Œåœ¨æ­¤ä¹Ÿæ¬¢è¿ä½ çš„åŠ å…¥ï¼
æˆ‘ä»¬çš„æ„¿æ™¯ å»¶ç»­ NexT ç»å…¸çš„é»‘ç™½è°ƒæ­é…ï¼Œä¿æŒç®€å•çš„æ˜“ç”¨æ€§åŠå¼ºå¤§çš„åŠŸèƒ½ã€‚
ä½¿ç”¨åé¦ˆ åŠ å…¥ GitHub Discussions æˆ– Gitter åœ¨çº¿è®¨è®º ğŸ» GitHub Issues æäº¤é”™è¯¯æŠ¥å‘Š ğŸ› GitHub Feature è¡¨æ–°åŠŸèƒ½çš„æƒ³æ³• âœ¨ åŒæ—¶å›½å†…ç”¨æˆ·ä¹Ÿå¯åŠ å…¥ QQ ç¾¤äº¤æµï¼š 604710815</content></entry><entry><title>ç«™ç‚¹ç¤ºä¾‹</title><url>/flinks.html</url><categories/><tags/><content type="html"> å¦‚æƒ³äº¤æ¢æœ¬ç«™å‹æƒ…é“¾æ¥ï¼Œè¯·åœ¨è¯„è®ºåŒºç•™ä¸‹ä½ çš„ç«™ç‚¹ä¿¡æ¯ï¼Œæ ¼å¼å‚è€ƒå¦‚ä¸‹ï¼š
- name: Hugo-NexT desc: Hugo NexT å®˜æ–¹é¢„è§ˆç½‘ç«™ã€‚ avatar: https://hugo-next.eu.org/imgs/hugo_next_avatar.png link: https://hugo-next.eu.org</content></entry></search>